<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boyoung</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="//boyoung.me/"/>
  <updated>2016-12-14T03:00:45.413Z</updated>
  <id>//boyoung.me/</id>
  
  <author>
    <name>Boyoung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>坂井泉水，负けないで</title>
    <link href="//boyoung.me/2016/02/10/%E5%9D%82%E4%BA%95%E6%B3%89%E6%B0%B4%EF%BC%8C%E8%B4%9F%E3%81%91%E3%81%AA%E3%81%84%E3%81%A7/"/>
    <id>//boyoung.me/2016/02/10/坂井泉水，负けないで/</id>
    <published>2016-02-10T13:07:09.000Z</published>
    <updated>2016-12-14T03:00:45.413Z</updated>
    
    <content type="html"><![CDATA[<audio src="https://drive.google.com/uc?export=download&id=0B_vBhIKbNtVSd3F1Y1lzZm9SVEk" controls></audio>

<p><img src="/images/20160210/20160210.jpg" alt=""></p>
<h2 id="致敬老姐永恒"><a href="#致敬老姐永恒" class="headerlink" title="致敬老姐永恒"></a>致敬老姐永恒</h2><p>今年的2月10日是zard出道的第二十五年。<br>怀念一下泉水姐姐。<br>非要形容老姐的话，她的「永遠」可以描述这种感觉。<br>没有一点刺激性，泉水一般的美人，给人的感觉非常舒服。<a id="more"></a></p>
<h2 id="出淤泥而不染，濯清涟而不妖"><a href="#出淤泥而不染，濯清涟而不妖" class="headerlink" title="出淤泥而不染，濯清涟而不妖"></a>出淤泥而不染，濯清涟而不妖</h2><p>一位笔者将老姐的美分为“天性美”、“诗性美”等，当时看完后个人而言是非常同意的。<br>因为你可以在她身上发现男性的潇洒帅气、女性的甜美坚强、孩子的淘气心性以及成人的豁达气质。<br><img src="/images/20160210/1.jpg" alt=""><br>中学时期，擅长运动，精通网球和长跑，神奈川长跑比赛破女子纪录。<br>曾在早期说自己给人的印象是冷。<br>其实内心中是一个敏感，感情充沛的人～<br>从她的歌词就可以看出来了。<br>前期唱过的歌，个人非常喜欢不要认输，特别激励人心的一首歌。<br>乐队成员在91年前后逐个离开，她一个人一直支撑着zard。<br>对于工作，她曾经说过“从起床开始，自己的生活就和音乐紧密相关。”<br>爱纪录生活中的一点一滴，将它们编入歌词，有很多写满记忆碎片的小本本。<br>爱在深夜工作，早起困难户。<br>不爱将工作局促于录音棚的空间，热爱于生活中寻找灵感。<br>和她合作过的人，都赞叹她的敬业。<br><img src="/images/20160210/4.jpg" alt=""><br>对于生活，热爱摄影、油画、花环制作。<br>经常去国外找灵感，去国外总爱流连各类画展。<br>比较低调，几乎不参加采访和电视节目（特别是后期）。<br>常常素颜单衣，扎着麻花。<br>后来生病，依旧乐观。总觉得自己会康复，对病情不甚在意。<br>后来的离开是一场意外。<br>出淤泥而不染，濯清涟而不妖。<br>足以形容她的一生。 </p>
<h2 id="音乐唱响一世"><a href="#音乐唱响一世" class="headerlink" title="音乐唱响一世"></a>音乐唱响一世</h2><p>无论你知不知道泉水姐姐，你必然听过她创作的歌曲。<br><img src="/images/20160210/3.jpg" alt=""><br>作为二次元爱好者来回答一下。<br>中华小当家OP2《无法呼吸》（中华一番最喜欢的OP）<br>灌篮高手ED4《My Friend》（不亚于《直到世界的尽头》的经典）<br>名侦探柯南OP4《转动命运之轮》（最伟大的柯南片头曲之一）<br>名侦探柯南OP15《星之光芒》<br>名侦探柯南OP21《光辉的信念》<br>名侦探柯南OP22《爱在黑暗中》<br>名侦探柯南ED17《梦见明天》<br>名侦探柯南ED24《好悲伤，却依旧喜欢你》<br>名侦探柯南M2《仿佛回到少女时代》<br>名侦探柯南M9《等待夏日的航帆》<br>名侦探柯南M12《展开双翼》<br>龙珠GT OP原作词、翻唱《DAN DAN 渐渐被你吸引<br>龙珠GT ED《Don’t You See》</p>
<p>负けないで！</p>
<p>简单提及一下老姐的词吧。</p>
<p>「もう少し，あと少し…」：</p>
<blockquote>
<p>きまぐれな九月の雨に（反反复复九月的雨中）<br>白い傘の少女がすれ違う（撑着白伞的少女擦肩而过）</p>
</blockquote>
<p>「負けないで」：</p>
<blockquote>
<p>ふとした瞬間に視線がぶつかる（偶然的一瞬间与你四目相接）</p>
</blockquote>
<p>「マイ　フレンド」：</p>
<blockquote>
<p>いつも輝いていたね　少年のまま　瞳はMy friend（少年时代 曾经一直闪耀的你的明眸 My friend）<br>あなたを想うだけで　心は強くなれた（只要想起你 内心就会变得坚强）<br>ずっと見つめてるから　走り続けて（我会一直注视着你 所以请继续勇往直前）</p>
</blockquote>
<p>还有永远。<br>歌词总是最能反映创作者心灵的。<br>姐姐的声音是能给人带来希望的。<br>这也是我喜欢听日文歌的原因。<br>能带来共鸣。<br><img src="/images/20160210/2.jpg" alt=""><br>姐姐走了。<br>大概上帝不愿意让她变老。<br>希望姐姐永远年轻漂亮。<br>希望姐姐永远坚强。<br>希望自己永远坚强。<br>希望老姐和zard精神不灭。</p>
]]></content>
    
    <summary type="html">
    
      &lt;audio src=&quot;https://drive.google.com/uc?export=download&amp;id=0B_vBhIKbNtVSd3F1Y1lzZm9SVEk&quot; controls&gt;&lt;/audio&gt;

&lt;p&gt;&lt;img src=&quot;/images/20160210/20160210.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;致敬老姐永恒&quot;&gt;&lt;a href=&quot;#致敬老姐永恒&quot; class=&quot;headerlink&quot; title=&quot;致敬老姐永恒&quot;&gt;&lt;/a&gt;致敬老姐永恒&lt;/h2&gt;&lt;p&gt;今年的2月10日是zard出道的第二十五年。&lt;br&gt;怀念一下泉水姐姐。&lt;br&gt;非要形容老姐的话，她的「永遠」可以描述这种感觉。&lt;br&gt;没有一点刺激性，泉水一般的美人，给人的感觉非常舒服。
    
    </summary>
    
    
      <category term="essay" scheme="//boyoung.me/tags/essay/"/>
    
      <category term="坂井泉水" scheme="//boyoung.me/tags/%E5%9D%82%E4%BA%95%E6%B3%89%E6%B0%B4/"/>
    
      <category term="追忆" scheme="//boyoung.me/tags/%E8%BF%BD%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="//boyoung.me/2015/09/15/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>//boyoung.me/2015/09/15/线性表/</id>
    <published>2015-09-15T10:27:39.000Z</published>
    <updated>2017-03-22T07:15:48.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为线性表"><a href="#何为线性表" class="headerlink" title="何为线性表"></a>何为线性表</h2><p>线性表的划分是从数据的逻辑结构上进行的。线性指的是在数据的逻辑结构上是线性的。即在数据元素的非空有限集中：</p>
<p>(1) 存在唯一的一个被称作“第一个”的数据元素；</p>
<p>(2) 存在唯一的一个被称作“最后一个”的数据元素；</p>
<p>(3) 除第一个外，集合中的每个数据元素均只有一个前继元素；</p>
<p>(4) 除最后一个外，集合中的每个数据元素均只有一个后继元素。<a id="more"></a></p>
<p>对于线性表，从存储结构上分，可以分为顺序存储结构和链式存储结构。</p>
<p>结构如下：</p>
<p><img src="/images/20150915/1.png" alt=""></p>
<p>定义线性表基本的变量和结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASTABLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//  线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10   <span class="comment">//  线性表存储空间的初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Book ElemType; <span class="comment">//定义数据类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType * elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;     <span class="comment">//定义线性表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**&lt;</span><br><span class="line"> 对数据类型进行定义</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> item1;</span><br><span class="line">&#125;BElemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> LinkList&#123;</span><br><span class="line">    BElemtype elem;</span><br><span class="line">    <span class="keyword">struct</span> LinkList *next;</span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Book&#123;</span><br><span class="line">		<span class="keyword">char</span>  name[<span class="number">50</span>];</span><br><span class="line">		LinkList *head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="顺序存储结构实现线性表"><a href="#顺序存储结构实现线性表" class="headerlink" title="顺序存储结构实现线性表"></a>顺序存储结构实现线性表</h2><p>构造一个空的线性表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">InitList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">  L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>( LIST_INIT_SIZE * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">  <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  L-&gt;length = <span class="number">0</span>;</span><br><span class="line">  L-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁线性表L：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">DestroyList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;elem);</span><br><span class="line">    L-&gt;elem = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;listsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将L重置为空表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ClearList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;elem);</span><br><span class="line">    L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若L为空表，则返回TRUE,否则返回FALSE：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">     <span class="keyword">if</span>(L.length == <span class="number">0</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> FALSE ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用e返回L中第i个数据元素的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &lt;= i &amp;&amp; i &lt;= L.length)&#123;</span><br><span class="line">        *e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回L中第1个与e满足关系compare（）关系的数据元素的位序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L, ElemType e, status (*compare)(ElemType e1, ElemType e2))&#123;</span><br><span class="line">    if(L.elem==NULL)</span><br><span class="line">        return ERROR;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=L.length ; i&gt;0 ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(compare(e,L.elem[i-1]))</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; //不存在则返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">PriorElem</span><span class="params">(SqList L,ElemType cur_e,ElemType *pre_e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e_now;</span><br><span class="line">    e_now = LocateElem(L, cur_e, equal);</span><br><span class="line">    <span class="keyword">if</span>(e_now &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            *pre_e = L.elem[e_now - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The element is the first one of the list.And so the pre_e is not defined."</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">NextElem</span><span class="params">(SqList L,ElemType cur_e,ElemType *next_e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    i = LocateElem(L,cur_e,equal);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> *next_e=L.elem[i] ;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在L的第i个位置之前插入新的数据元素e，L的长度加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length &gt;= L-&gt;listsize)&#123;</span><br><span class="line">        ElemType * newbase;</span><br><span class="line">        newbase = (ElemType *)<span class="built_in">realloc</span>(L-&gt;elem, (L-&gt;listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;elem = newbase;</span><br><span class="line">        L-&gt;listsize += LISTINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType *p;</span><br><span class="line">    ElemType *q;</span><br><span class="line">    q = &amp;(L-&gt;elem[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L-&gt;elem[L-&gt;length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">        *(p+<span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除L的第i个数据元素，用e返回其值，L的长度减1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length) <span class="keyword">return</span> ERROR;</span><br><span class="line">   	<span class="keyword">for</span>(;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;elem[i<span class="number">-1</span>]=L-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    --L-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次对L的每个数据元素调用函数visit()。一旦调用失败，则操作失败：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">status ListTrabverse(SqList L, void (*visit)(ElemType e))&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(!L.length) return ERROR;</span><br><span class="line">    printf("\n-----------all elements -----------------------\n");</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">        visit(L.elem[i]);</span><br><span class="line">    printf("\n------------------ end ------------------------\n");</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将文件中内容读取至构造的线性表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ReadFile</span><span class="params">(<span class="keyword">char</span> path[], SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    FILE *pfile = fopen(path, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfile==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n----warning:数据文件打开失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(pfile, <span class="string">"%d"</span>, &amp;(L-&gt;listsize));</span><br><span class="line">    L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(L-&gt;listsize*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">       <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    fgetc(pfile);</span><br><span class="line">    <span class="built_in">fscanf</span>(pfile, <span class="string">"%d"</span>, &amp;(L-&gt;length));</span><br><span class="line">    fgetc(pfile);</span><br><span class="line">    fread(L-&gt;elem, <span class="keyword">sizeof</span>(ElemType), L-&gt;listsize, pfile);</span><br><span class="line">    fclose(pfile);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将录入的线性表中内容保存至文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">SaveFile</span><span class="params">(<span class="keyword">char</span> path[], SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    FILE *pfile = fopen(path, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfile==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------%40s--------\n"</span>,<span class="string">"warning:存储文件打开失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    <span class="built_in">fprintf</span>(pfile, <span class="string">"%d"</span>, L-&gt;listsize);</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    <span class="built_in">fprintf</span>(pfile, <span class="string">"%d"</span>, L-&gt;length);</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    fwrite(L-&gt;elem, <span class="keyword">sizeof</span>(ElemType), L-&gt;listsize, pfile);</span><br><span class="line"></span><br><span class="line">    fclose(pfile);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式存储结构实现线性表"><a href="#链式存储结构实现线性表" class="headerlink" title="链式存储结构实现线性表"></a>链式存储结构实现线性表</h2><p>采用带表头结点的单链表作为线性表的物理结构，实现对多个单链表实现操作。</p>
<p>物理结构如下：</p>
<p><img src="/images/20150915/2.png" alt=""></p>
<p>可以借此设计个图书管理系统，数据对象为学校和书目。</p>
<p>学校即为上面线性表直接实现的，而书目即为链表实现。</p>
<p>修改下BElemType的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;BElemType;</span><br></pre></td></tr></table></figure>
<p>其中各学校功能函数定义与描述即为上述线性表的实现。</p>
<p>现在来实现某学校图书馆各书目索取函数定义与描述。</p>
<p>构造一个空的单链表：</p>
<p>主要思想是新建一链表头结点，开始时指针为空，名称为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BInitList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	*L = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>((*L)-&gt;elem.name, <span class="string">" "</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除单链表：</p>
<p>主要思想是依次遍历链表每个节点，释放存储空间，最后使头结点为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BDestroyList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	LinkList *q;</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">while</span> (*L) &#123;</span><br><span class="line">		q = *L;</span><br><span class="line">		*L = (*L)-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	*L = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空单链表：</p>
<p>主要思想即是与破坏链表不同在于还存在头结点，因此可结合新建链表与破坏链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BClearList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	BDestroyList(L);</span><br><span class="line">	BInitList(L);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表是否空：</p>
<p>主要思想即判断头结点的next是否为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListEmpty</span><span class="params">(LinkList *L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表长度：</p>
<p>主要思想即添加计数变量i，依次循环遍历链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BListLength</span><span class="params">(LinkList *L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	LinkList *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i++, p = p-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下标找元素：</p>
<p>主要思想是通过输入的数，来确定遍历链表的次数，以此找到遍历的那个元素，来访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BGetElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, BElemType *e)</span> </span>&#123;</span><br><span class="line">	LinkList *p;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;BListLength(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++, p = p-&gt;next);</span><br><span class="line">	*e = p-&gt;elem;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过元素找下标：</p>
<p>主要思想是遍历链表的过程中通过比较函数比较链表数据和输入数据来确定位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int BLocateElem(LinkList *L, BElemType e, status (*compare)(BElemType e1, BElemType e2)) &#123;</span><br><span class="line">	if (L = NULL)</span><br><span class="line">		return ERROR;</span><br><span class="line">	LinkList *p = L-&gt;next;</span><br><span class="line">	int i = 1;</span><br><span class="line">	for (; p != NULL;p=p-&gt;next,i++)</span><br><span class="line">	&#123;</span><br><span class="line">	if(compare(e, p-&gt;elem))</span><br><span class="line">			return i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找前继：</p>
<p>主要思想是通过LocateElem得到输入元素的位置，再通过GetElem得到前一位置的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BPriorElem</span><span class="params">(LinkList *L, BElemType cur_e, BElemType *pre_e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> e_now;</span><br><span class="line">	e_now = BLocateElem(L, cur_e, Bequal);</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (e_now == ERROR) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BGetElem(L, e_now - <span class="number">1</span>, pre_e) == ERROR) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Bequal函数实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">Bequal</span><span class="params">(BElemType e1, BElemType e2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcpy</span>(e1.name, e2.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找后继：</p>
<p>思想同PriorElem。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BNextElem</span><span class="params">(LinkList *L, BElemType cur_e, BElemType *next_e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> e_now;</span><br><span class="line">	e_now = BLocateElem(L, cur_e, Bequal);</span><br><span class="line">	*next_e = L-&gt;elem;</span><br><span class="line">	<span class="keyword">if</span> (L = <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (e_now == ERROR)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BGetElem(L, e_now + <span class="number">1</span>, next_e) == ERROR)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<p>主要思想是将元素插入至新开辟的一个数据空间内，再改变链表指针指向即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListInsert</span><span class="params">(LinkList **L, <span class="keyword">int</span> i, BElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList *p, *pnow;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; BListLength(*L) + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	pnow = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">	pnow-&gt;elem = e;</span><br><span class="line">	<span class="keyword">if</span> (!pnow)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	p = *L;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; p != <span class="literal">NULL</span>; p = p-&gt;next, j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123;</span><br><span class="line">			pnow-&gt;next = p-&gt;next;</span><br><span class="line">			p-&gt;next = pnow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<p>主要思想是通过i遍历链表到该位置，通过e保存该数据，再free掉该指针所指向空间即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, BElemType *e)</span> </span>&#123;</span><br><span class="line">	LinkList *p,*q;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; BListLength(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	*e = p-&gt;next-&gt;elem;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="comment">//p = p-&gt;next;</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，基本的函数就完成了。</p>
<p>其中有一个易错点就是通过线性表来获取链表头结点，即通过学校进入图书馆。</p>
<p>先给出我的程序基本菜单：</p>
<p><img src="/images/20150915/3.png" alt=""></p>
<p>也即为六号功能。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	<span class="keyword">if</span> (Bflag) <span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n-----请输入学校号："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (GetElem(L, i) == OK)</span><br><span class="line">	&#123;</span><br><span class="line">		BB = &amp;(L.elem[i - <span class="number">1</span>].head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"查询成功，学校名为%s!\n"</span>, L.elem[i<span class="number">-1</span>].name);</span><br><span class="line">		Bflag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Wrong.Please input the i again."</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>线性表的操作便完全介绍完啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何为线性表&quot;&gt;&lt;a href=&quot;#何为线性表&quot; class=&quot;headerlink&quot; title=&quot;何为线性表&quot;&gt;&lt;/a&gt;何为线性表&lt;/h2&gt;&lt;p&gt;线性表的划分是从数据的逻辑结构上进行的。线性指的是在数据的逻辑结构上是线性的。即在数据元素的非空有限集中：&lt;/p&gt;
&lt;p&gt;(1) 存在唯一的一个被称作“第一个”的数据元素；&lt;/p&gt;
&lt;p&gt;(2) 存在唯一的一个被称作“最后一个”的数据元素；&lt;/p&gt;
&lt;p&gt;(3) 除第一个外，集合中的每个数据元素均只有一个前继元素；&lt;/p&gt;
&lt;p&gt;(4) 除最后一个外，集合中的每个数据元素均只有一个后继元素。
    
    </summary>
    
    
      <category term="blog" scheme="//boyoung.me/tags/blog/"/>
    
      <category term="卖萌打滚求offer" scheme="//boyoung.me/tags/%E5%8D%96%E8%90%8C%E6%89%93%E6%BB%9A%E6%B1%82offer/"/>
    
      <category term="数据结构" scheme="//boyoung.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概念总览</title>
    <link href="//boyoung.me/2015/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%80%BB%E8%A7%88/"/>
    <id>//boyoung.me/2015/09/10/数据结构概念总览/</id>
    <published>2015-09-10T11:03:09.000Z</published>
    <updated>2017-03-21T06:39:55.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机技术"><a href="#计算机技术" class="headerlink" title="计算机技术"></a>计算机技术</h1><p>计算机技术的两大支柱：1是数据结构，2是算法。</p>
<p>因此毫不夸张的在某种程度上讲，程序设计等同于设计数据结构+算法。 <a id="more"></a></p>
<h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p>线性结构的逻辑特征：有且仅有一个开始结点和终端结点，并且所有结点最多只有一个直接前驱和直接后继。如：线性表、栈、队列。</p>
<p>非线性结构的逻辑特征：一个结点可能有0、1、或多个直接前驱，直接后继。如：树、图、网、集合。</p>
<h2 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h2><p>顺序存储方法：把逻辑上相邻的结点存储在物理位置上相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。</p>
<p>链接存储方法：不要求逻辑上相邻的结点在物理位置上也相邻，结点间的逻辑关系由附加的指针字段表示。</p>
<p>索引存储方法：在存储结点信息的同时，还建立附加的索引表。</p>
<p>散列存储方法：根据结点的关键字直接计算出该结点的存储地址。</p>
<h2 id="简易分类"><a href="#简易分类" class="headerlink" title="简易分类"></a>简易分类</h2><p>线性表是一种逻辑结构，若采用顺序方法的存储表示，则为顺序表；若采用链接方法的存储表示，则为链表；若采用散列方法的存储表示，则为散列表；若对线性表上的插入、删除运算限制在表的一端进行，则为栈；若对插入限制在表的一端进行，而删除限制在表的另一端进行，则为队列。</p>
<p><img src="/images/20150910/1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机技术&quot;&gt;&lt;a href=&quot;#计算机技术&quot; class=&quot;headerlink&quot; title=&quot;计算机技术&quot;&gt;&lt;/a&gt;计算机技术&lt;/h1&gt;&lt;p&gt;计算机技术的两大支柱：1是数据结构，2是算法。&lt;/p&gt;
&lt;p&gt;因此毫不夸张的在某种程度上讲，程序设计等同于设计数据结构+算法。
    
    </summary>
    
    
      <category term="blog" scheme="//boyoung.me/tags/blog/"/>
    
      <category term="卖萌打滚求offer" scheme="//boyoung.me/tags/%E5%8D%96%E8%90%8C%E6%89%93%E6%BB%9A%E6%B1%82offer/"/>
    
      <category term="数据结构" scheme="//boyoung.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>VS中scanf函数说明</title>
    <link href="//boyoung.me/2015/08/02/VS%E4%B8%ADscanf%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/"/>
    <id>//boyoung.me/2015/08/02/VS中scanf函数说明/</id>
    <published>2015-08-02T11:51:45.000Z</published>
    <updated>2016-12-11T13:11:29.636Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，由于安全原因，vs2012版本及其以上会出现scanf函数报错的情形，编译时便会提示如下错误<a id="more"></a>：</p>
<blockquote>
<p>error C4996: ‘scanf’: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
</blockquote>
<p>错误解释：</p>
<p>微软该种类型报错主要因为那些C库的函数，很多函数内部是不进行参数检测的（包括越界类的），微软担心使用这些会造成内存异常，所以就改写了同样功能的函数，改写了的函数进行了参数的检测，使用这些新的函数会更安全和便捷。关于这些改写的函数你不用专门去记忆，因为编译器对于每个函数在给出警告时，都会告诉你相应的安全函数，查看警告信息就可以获知，在使用时也再查看一下MSDN详细了解。</p>
<h3 id="一般来说，直接解决该问题方法有三种："><a href="#一般来说，直接解决该问题方法有三种：" class="headerlink" title="一般来说，直接解决该问题方法有三种："></a>一般来说，直接解决该问题方法有三种：</h3><p>方法一：将原来的旧函数替换成新的 Security CRT functions，即替换成为新的函数scanf_s，但是scanf_s函数比scanf函数多了一个参数，即读取个数参数。例如scanf从输入流中读取一个字符类型字节,scanf(“%c”,&amp;ch),则若使用scanf_s需改为scanf_s(“%c”,&amp;ch,1);</p>
<p>方法二：以下方法的原理为屏蔽这个错误：</p>
<ol>
<li>在预编译头文件stdafx.h里（注意：一定要在没有include任何头文件之前）定义下面的宏：</li>
</ol>
<blockquote>
<pre><code>#define _CRT_SECURE_NO_DEPRECATE
</code></pre></blockquote>
<ol>
<li><p>或声明 #param warning(disable:4996)</p>
</li>
<li><p>更改预处理定义：</p>
</li>
</ol>
<blockquote>
<p>项目-&gt;属性-&gt;配置属性-&gt;C/C++ -&gt; 预处理器 -&gt; 预处理器定义，增加：</p>
</blockquote>
<pre><code>_CRT_SECURE_NO_DEPRECATE
</code></pre><blockquote>
<p>第三种注意更改预处理定义时若在最后面加上该句话，需在这句话前面即未加之前最后面加上一个分号（在英文输入法模式下）。</p>
</blockquote>
<p>方法三：方法二没有使用更加安全的 CRT 函数，显然不是一个值得推荐的好方法，但我们又不想一个一个地改函数名，这里还有一个更简便的方法：</p>
<blockquote>
<p>在预编译头文件 stdafx.h 里（同样要在没有include任何头文件之前）定义下面的宏：</p>
</blockquote>
<pre><code>#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
</code></pre><blockquote>
<p>在链接的时候便会自动将旧函数替换成 Security CRT functions 。</p>
<p>注意：这个方法虽然使用了新的函数，但是不能消除警告，你还得同时使用方法二(-_-)。即实际应在预编译头文件 stdafx.h 里加入下面两句：</p>
</blockquote>
<pre><code>#define _CRT_SECURE_NO_DEPRECATE

#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
</code></pre><p>虽然解决了该报错问题，但是很多童鞋会发现运行时，scanf函数虽然并未报错，即该程序正确执行，但是在输入时，会发现scanf函数跳过输入字符的原因，即你没有办法输入的问题，这是为什么呢？</p>
<p>因为scanf只是读入一个字符,而你在输入时实际上输入的是:字符+回车(Enter),Enter产生的”\n”也在输入缓冲区中,下次调用 scanf时就会直接读到 它而不是等待你再次输入!所以我们不提倡使用 scanf(“%c”, …),特别是不提倡把它用在循环中。这也是微软改写该类函数的原因，那么如何解决呢？</p>
<h3 id="一把来说，主要方法有四种："><a href="#一把来说，主要方法有四种：" class="headerlink" title="一把来说，主要方法有四种："></a>一把来说，主要方法有四种：</h3><p>方法一：只要再加一句scanf就行了。</p>
<p>方法二：使用函数fflush，清除流，就是在每个接收字符的scanf语句前面,加上fflush(stdin);</p>
<p>方法三：将 scanf(“%c”, &amp;ch); 修改为:     scanf(“ %c”, &amp;ch);    /<em>在%前加上一个空格</em>/</p>
<p>方法四：将 scanf(“%c”, &amp;ch); 修改为:     scanf(“%c%<em>c”, &amp;ch);   %</em>c是跳过一个输入字符的意思.这个是scanf的一个语法.就是在%和格式字符之间加一个<em>号就可以跳过这个输入数字.比如当执行语句:scanf(“%c,%</em>c,%c”,&amp;a,&amp;b);时,我输入m,n,p三个字母后,a的值为m,b值为p,n被跳过了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，由于安全原因，vs2012版本及其以上会出现scanf函数报错的情形，编译时便会提示如下错误
    
    </summary>
    
    
      <category term="blog" scheme="//boyoung.me/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客</title>
    <link href="//boyoung.me/2015/07/11/Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>//boyoung.me/2015/07/11/Hexo博客/</id>
    <published>2015-07-11T13:07:09.000Z</published>
    <updated>2017-03-20T11:58:27.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo博客初建"><a href="#Hexo博客初建" class="headerlink" title="Hexo博客初建"></a>Hexo博客初建</h2><p>闲来无事，便打算给自己做一个个人网站，用于分享知识、记录心情的个人小站，最后喜欢上了hexo，这是初衷。<a id="more"></a></p>
<p>具体的搭建方法也是参考的别人，具体详见<a href="http://qrframe.com/2016/07/13/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/" target="_blank" rel="external">使用hexo搭建个人网站</a>。</p>
<p>我使用的主题为yelee，简洁、美观而又大方。具体的可以详细搜索做这个主题前端的大佬，可以详细参考下。</p>
<p>博客搭建好后，还可以绑定自己的域名，我使用的域名boyoung.me便是从阿里云购买的，详细绑定方法见<a href="http://quantumman.me/blog/setting-up-a-domain-with-gitHub-pages.html" target="_blank" rel="external">GitHub Pages 绑定来自阿里云的域名</a>。</p>
<h2 id="Hexo简单使用"><a href="#Hexo简单使用" class="headerlink" title="Hexo简单使用"></a>Hexo简单使用</h2><h3 id="1、new"><a href="#1、new" class="headerlink" title="1、new"></a>1、new</h3><blockquote>
<p>hexo new [layout] <title></title></p>
</blockquote>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="2、generate"><a href="#2、generate" class="headerlink" title="2、generate"></a>2、generate</h3><blockquote>
<p>hexo g</p>
</blockquote>
<p>生成静态文件。</p>
<h3 id="3、server"><a href="#3、server" class="headerlink" title="3、server"></a>3、server</h3><blockquote>
<p>hexo s</p>
</blockquote>
<p>启动服务器。</p>
<h3 id="4、deploy"><a href="#4、deploy" class="headerlink" title="4、deploy"></a>4、deploy</h3><blockquote>
<p>hexo g</p>
</blockquote>
<p>部署网站。</p>
<h3 id="5、clean"><a href="#5、clean" class="headerlink" title="5、clean"></a>5、clean</h3><blockquote>
<p>hexo clean</p>
</blockquote>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo博客初建&quot;&gt;&lt;a href=&quot;#Hexo博客初建&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客初建&quot;&gt;&lt;/a&gt;Hexo博客初建&lt;/h2&gt;&lt;p&gt;闲来无事，便打算给自己做一个个人网站，用于分享知识、记录心情的个人小站，最后喜欢上了hexo，这是初衷。
    
    </summary>
    
    
      <category term="blog" scheme="//boyoung.me/tags/blog/"/>
    
      <category term="环境搭配" scheme="//boyoung.me/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/"/>
    
      <category term="Hexo起始" scheme="//boyoung.me/tags/Hexo%E8%B5%B7%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello Future</title>
    <link href="//boyoung.me/2015/07/10/Hello-Future/"/>
    <id>//boyoung.me/2015/07/10/Hello-Future/</id>
    <published>2015-07-10T04:10:26.000Z</published>
    <updated>2016-12-12T12:46:08.810Z</updated>
    
    <content type="html"><![CDATA[<p>撒花撒花，博客搭好，当然要立一些flags啦！希望这个hexo博客能让我更加进步！<a id="more"></a></p>
<h2 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h2><h3 id="College"><a href="#College" class="headerlink" title="College"></a>College</h3><blockquote>
<p>Huazhong University of Science and Technology.</p>
</blockquote>
<h3 id="Hobby"><a href="#Hobby" class="headerlink" title="Hobby"></a>Hobby</h3><blockquote>
<p>Tennis, Music, Reading.</p>
</blockquote>
<h3 id="Dream-Flags"><a href="#Dream-Flags" class="headerlink" title="Dream? Flags!"></a>Dream? Flags!</h3><blockquote>
<p>Le vent se lève, il faut tenter de vivre.</p>
</blockquote>
<h3 id="Maxim"><a href="#Maxim" class="headerlink" title="Maxim"></a>Maxim</h3><blockquote>
<p>以最小的代价完成生命各个维度的尝试。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;撒花撒花，博客搭好，当然要立一些flags啦！希望这个hexo博客能让我更加进步！
    
    </summary>
    
    
      <category term="essay" scheme="//boyoung.me/tags/essay/"/>
    
  </entry>
  
</feed>
