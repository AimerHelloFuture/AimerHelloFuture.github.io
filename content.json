{"meta":{"title":"Boyoung","subtitle":null,"description":null,"author":"Boyoung","url":"//boyoung.me"},"posts":[{"title":"JAVA面试","slug":"JAVA面试","date":"2017-06-03T06:56:41.000Z","updated":"2017-06-04T09:18:56.252Z","comments":true,"path":"2017/06/03/JAVA面试/","link":"","permalink":"//boyoung.me/2017/06/03/JAVA面试/","excerpt":"活到老学到老这篇文章会讲述一些在学习java过程中常遇到的问题，\n大都以面试题的形式为主，应该会持续更新（吧==立个flag）。\n这篇文章的完成会参考很多大佬们的博文，最主要的参考了一个系列文章\n在此表示感谢。","text":"活到老学到老这篇文章会讲述一些在学习java过程中常遇到的问题， 大都以面试题的形式为主，应该会持续更新（吧==立个flag）。 这篇文章的完成会参考很多大佬们的博文，最主要的参考了一个系列文章 在此表示感谢。 面向对象的特性有哪些？ 面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 1).方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 访问修饰符public,private,protected,以及不写（默认）时的区别？ | 修饰符 | 当前类 | 同包 | 子类 | 其他包 || :——-: | :–: | :–: | :–: | :–: || public | √ | √ | √ | √ || protected | √ | √ | √ | × || default | √ | √ | × | × || private | √ | × | × | × | 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 String 是最基本的数据类型吗？ 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 float f=3.4;是否正确？ 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型， 需要强制转换类型才能赋值给short型。 而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。 Java有没有goto？ goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） int和Integer有什么区别？ Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： 123456789public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 &amp;和&amp;&amp;的区别？ &amp;运算符有两种用法：(1)按位与；(2)逻辑与。 &amp;&amp;运算符是短路与运算。 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;， 例如在验证用户登录时判定用户名不是null而且不是空字符串， 应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。 null和””的区别 String s; String s=null; String s=””; 首先针对s都分配了空间，位于栈空间上，第一个未存入任何字符串对象，第二个存入了空字符串对象，但前两种并未在堆分配空间，第三种在堆上分配了空间。””代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。String s=null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间。String s=””;这个引用已经指向了一块是空字符串的内存空间。 针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出（未显示任何东西）。 12345String s=\"a\"和String s=new String(\"a\");是有本质上的区别的 前者是在字符串池里写入一个字符'a',然后用s指向它； 后者是在堆上创建一个内容为\"a\"的字符串对象。 String str=\"aaa\"; //于栈上分配内存 String str=new String(\"aaa\"); //于堆上分配内存 1234567891011121314151617181920但有个关键的一点,没有人说到，这就是: String s;在什么情况下可以等同于String s=null;而在什么情况下又不等同？！考虑下面的代码: //StringTest.java public class StringTest &#123; static String s; //* public static void main(String[] args) &#123; //String s; //** System.out.println(s); &#125; &#125; 编译并运行上面的代码,将打印null。 可见标有*号的行是自动初始化了的(s被自动初始化为null)。 而如果把标有**号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。 由此得出结论： 在成员变量的定义中,String s;等同于String s=null; 而在本地变量(方法变量)的定义中,String s;不等同于String s=null;,这时要使用s必须显式地赋值。 这些虽然是小知识点,但在实际应用中很重要,也很容易被一些人忽视,特此提出。 还有一点要说明的是： 只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值。 下面看张图就明白了。 String和StringBuilder、StringBuffer的区别？ Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。 面试题1 - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？ 如果在编写代码的过程中大量使用+进行字符串评价还是会对性能造成比较大的影响，但是使用的个数在1000以下还是可以接受的，大于10000的话，执行时间将可能超过1s，会对性能产生较大影响。如果有大量需要进行字符串拼接的操作，最好还是使用StringBuffer或StringBuilder进行。 面试题2 - 请说出下面程序的输出。 1234567891011121314151617181920212223/** * Created by lenovo on 2017/6/4. */public class TestString &#123; public static void main(String[] args) &#123; String s1 = \"HelloWorld\"; String s2 = \"HelloWorld\"; String s3 = new String(\"HelloWorld\"); String s4 = \"Hello\" + \"World\"; String s5 = \"Hello\" + new String(\"World\"); System.out.println(s1 == s2); System.out.println(s1 == s3); System.out.println(s1 == s4); System.out.println(s1 == s5); System.out.println(s1 == s1.intern()); System.out.println(s3 == s3.intern()); System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); System.out.println(s1.equals(s4)); System.out.println(s1.equals(s5)); &#125;&#125; truefalsetruefalsetruefalsetruetruetruetrue 注意String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。 ​","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"JAVA","slug":"JAVA","permalink":"//boyoung.me/tags/JAVA/"}]},{"title":"沙漠储油点问题","slug":"沙漠储油点问题","date":"2017-04-25T14:46:08.000Z","updated":"2017-04-26T15:16:51.798Z","comments":true,"path":"2017/04/25/沙漠储油点问题/","link":"","permalink":"//boyoung.me/2017/04/25/沙漠储油点问题/","excerpt":"前言，引发来源这道题：\n一个士兵要过一个120m的有毒的下水道，身上最多只能带90个解药，\n每走一米需要消耗一个解药，最少需要多少解药才能成功的走过下水道？\n一开始看到，看了半天，愣了半天？？？这是什么意思啊，这怎么过得去啊？？？","text":"前言，引发来源这道题： 一个士兵要过一个120m的有毒的下水道，身上最多只能带90个解药， 每走一米需要消耗一个解药，最少需要多少解药才能成功的走过下水道？ 一开始看到，看了半天，愣了半天？？？这是什么意思啊，这怎么过得去啊？？？ 后来才理解可以走多次，在路程中可以存储一下解药。 现来介绍类似的问题即沙漠储油点问题。 沙漠储油点一辆重型卡车欲穿过1000公里的沙漠，卡车耗油为1升/公里， 卡车总载油能力为500公升。显然卡车一次是过不了沙漠的。 因此司机必须设法在沿途建立几个储油点，使卡车能顺利穿越沙漠， 试问司机如何建立这些储油点？每一储油点应存多少油，才能使卡车以消耗最少油的代价通过沙漠？ 算法分析： 编程计算及打印建立的贮油点序号，各贮油点距沙漠边沿出发的距离以及存油量。 设dis[i] 为第i个贮油点至终点(i=0)的距离； oil[i] 为第i个贮油点的存贮油量； 我们可以用倒推法来解决这个问题。从终点向始点倒推，逐一求出每个贮油点的位置及存油量。 此图表示倒推时的返回点： 从贮油点i向贮油点i+1倒推的策略是，卡车在点i和点i+1间往返若干次。 卡车每次返回i+1处时正好耗尽500公升汽油，而每次从i+1出发时又必须装足500公升汽油。 两点之间的距离必须满足在耗油最少的条件下使i点贮足i乘500分升汽油的要求(0&lt;=i&lt;=n-1)。 具体地讲，第一个贮油点i=1应距终点i=0处500km且在该处贮藏500公升汽油， 这样才能保证卡车能由i=1处到达终点i=0处，这就是说 ​ dis[1]=500，oil[1]=500; 为了在i=1处贮藏500公升汽油，卡车至少从i=2处开两趟满载油的车至i=1处 （因为最多装500公升，所以需要两趟才可以在i=1处贮藏500公升）。 所以i=2处至少贮有2乘500公升汽油，即oil[2]=500乘2=1000。 另外，再加上从i=1返回至i=2处的一趟空载，合计往返3次。 三次往返路程的耗油量按最省要求只能为500公升。即 ​ dis[2]=dis[1]+500/3; 为了在i=2处贮存1000公升汽油，卡车至少从i=3处开三趟满载油的车至i=2处。 报以i=3处至少贮有3乘500公升汽油，即oil[3]=500乘3=1500。 加上i=2至i=3处的二趟返程空车，合计5次。 路途耗油量也应为500公升，即 ​ dis[3]=dis[2]+500/5; 依此类推，为了在i=k处贮藏k乘500公升汽油， 卡车至少从i=k+1处开k趟满载车至i=k处，即 ​ oil[k+1]=[k+1]乘500=oil[k]+500， 加上从i=k处返回i=k+1的k-1趟返程空间，合计2k-1次。 这2k-1次总耗油量按最省要求为500公升，即 ​ dis[k+1]=dis[k]+500/(2k-1); 最后，i=n至始点的距离为1000-dis[n],oil[n]=500乘n。 为了在i=n处取得n乘500公升汽油，卡车至少从始点开n+1次满载车至i=n， 加上从i=n返回始点的n趟返程空车，合计2n+1次， 2n+1趟的总耗油量应正好为(1000-dis[n])乘(2n+1)， 即始点藏油为oil[n]+(1000-dis[n])乘(2n+1)。 用C语言描述如下： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define MAX_STATION_NUM 32 /*定义最大允许的储油点数目*/ int main() &#123; int k, i; double wDistance; /*wDistance是终点至当前贮油点的距离*/ double storedOil[MAX_STATION_NUM];/*storedOil[i]是第i个储油点的储油量*/ double distance[MAX_STATION_NUM]; /*distance[i]是第i个储油点到终点的距离*/ puts(\"The whole distance is 1000km,and the result is:\\n\"); puts(\"station distance(km) oil(l)\"); k = 1; wDistance = 500; /*从i=1处开始向始点倒推*/ distance[1] = 500; storedOil[1] = 500; while(1) &#123; k++; wDistance += 500 / (2 * k - 1); distance[k] = wDistance; storedOil[k] = storedOil[k-1] + 500; if(wDistance &gt;= 1000) break; &#125; distance[k] = 1000; /*置始点至终点的距离值*/ storedOil[k] = (1000 - distance[k-1]) * (2 * k + 1) + storedOil[k-1]; /*求始点藏油量*/ for(i = 0; i &lt; k; i++) /*由始点开始逐一打印始点至当前贮油点的距离和藏油量*/ printf(\"%4d %6.3f %6.3f\\n\", i, 1000-distance[k-i], storedOil[k-i]); system(\"pause\"); return 0; &#125; 储油点扩展问题运油问题。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"算法","slug":"算法","permalink":"//boyoung.me/tags/算法/"}]},{"title":"TCP连接","slug":"TCP连接","date":"2017-04-20T02:57:08.000Z","updated":"2017-04-22T03:17:59.672Z","comments":true,"path":"2017/04/20/TCP连接/","link":"","permalink":"//boyoung.me/2017/04/20/TCP连接/","excerpt":"TCP连接状态一条tcp连接，主动关闭的一方不可能出现的连接状态是()","text":"TCP连接状态一条tcp连接，主动关闭的一方不可能出现的连接状态是() CLOSE_WAIT FIN_WAIT2 TIME_WAIT FIN_WAIT1 先来一张一目了然的图： 现在来详细解释TCP连接建立与关闭过程中的状态。 TCP连接过程是状态的转换，促使状态发生转换的因素包括用户调用、特定数据包以及超时等， 具体状态如下所示： CLOSED ：初始状态，表示没有任何连接。 LISTEN ： Server 端的某个 Socket 正在监听来自远方的 TCP 端口的连接请求。 SYN_SENT ：发送连接请求后等待确认信息。当客户端 Socket 进行 Connect 连接时， 会首先发送 SYN 包，随即进入 SYN_SENT状态， 然后等待 Server 端发送三次握手中的第 2 个包。 SYN_RECEIVED ：收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。 通常是建立 TCP 连接的三次握手过程中的一个中间状态， 表示 Server 端的 Socket 接收到来自 Client 的 SYN 包，并作出回应。 ESTABLISHED ：表示连接已经建立，可以进行数据传输。 FIN_WAIT_1 ：主动关闭连接的一方等待对方返回 ACK 包。 若 Socket 在 ESTABLISHED 状态下主动关闭连接并向对方发送 FIN 包（表示己方不再有数据需要发送）， 则进入 FIN_WAIT1 状态，等待对方返回 ACK 包，此后还能读取数据，但不能发送数据。 在正常情况下，无论对方处于何种状态，都应该马上返回 ACK 包， _所以 FIN_WAIT_1 状态一般很难见到。 FIN_WAIT_2 ：主动关闭连接的一方收到对方返回的 ACK 包后，等待对方发送 FIN 包。 处于 FIN_WAIT_1 状态下的 Socket 收到了对方返回的 ACK 包后，便进入 FIN_WAIT_2 状态。 由于 FIN_WAIT2 状态下的 Socket 需要等待对方发送的 FIN 包，所有常常可以看到。 _若在 FIN_WAIT_1 状态下收到对方发送的同时带有 FIN 和 ACK 的包时， 则直接进入 TIME_WAIT 状态，无须经过FIN_WAIT_2 状态。 TIME_WAIT ：主动关闭连接的一方收到对方发送的 FIN 包后返回 ACK 包 （表示对方也不再有数据需要发送，此后不能再读取或发送数据）， 然后等待足够长的时间（ 2MSL ）以确保对方接收到 ACK 包 （考虑到丢失 ACK 包的可能和迷路重复数据包的影响）， 最后回到 CLOSED 状态，释放网络资源。 CLOSE_WAIT ：表示被动关闭连接的一方在等待关闭连接。 当收到对方发送的 FIN 包后（表示对方不再有数据需要发送），相应的返回 ACK 包， 然后进入 CLOSE_WAIT 状态。在该状态下，若己方还有数据未发送， 则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。 LAST_ACK ：被动关闭连接的一方在 CLOSE_WAIT 状态下完成数据的发送后 便可向对方发送 FIN 包（表示己方不再有数据需要发送），然后等待对方返回 ACK 包。 收到 ACK 包后便回到 CLOSED 状态，释放网络资源。 CLOSING ：比较罕见的例外状态。正常情况下，发送 FIN 包后应该先收到（或同时收到） 对方的 ACK 包，再收到对方的 FIN 包，而 CLOSING 状态表示发送 FIN 包后并没有收到对方的 ACK 包， 却已收到了对方的 FIN 包。有两种情况可能导致这种状态： 其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送 FIN 包的情况； 其二，如果 ACK 包丢失而对方的 FIN 包很快发出，也会出现 FIN 先于 ACK 到达。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"计算机网络","slug":"计算机网络","permalink":"//boyoung.me/tags/计算机网络/"}]},{"title":"计算机中的数","slug":"计算机中的数","date":"2017-04-04T03:24:16.000Z","updated":"2017-04-22T03:33:01.684Z","comments":true,"path":"2017/04/04/计算机中的数/","link":"","permalink":"//boyoung.me/2017/04/04/计算机中的数/","excerpt":"前言因为计算机的二进制表示特性，造就了与自然界数的运算产生了有趣的差异。\n比如：一个数的绝对值一定是非负数吗？","text":"前言因为计算机的二进制表示特性，造就了与自然界数的运算产生了有趣的差异。 比如：一个数的绝对值一定是非负数吗？ math.h的abs返回值math.h的abs返回值() 不可能是负数 不可能是正数 都有可能 不可能是0 首先来看c中的函数申明： 1int abs(int num); 正常情况下, num为0或正数时，函数返回num值； 当num为负数且不是最小的负数时，函数返回num的对应绝对值数， 即将内存中该二进制位的符号位取反，并把后面数值位取反加一； 当num为最小的负数时（即0x80000000），由于正数里int类型32位表示不了这个数的绝对值， 所以依然返回该负数。 这就是设计这个库函数的时候为什么把返回值设置为int而不是unsigned的原因。 因此答案是C。 因为负数的范围比正数大一个,比如8位的二进制，可以表示范围为-128~127 所以abs(-128)可能并不能表示为128，所以只能返回原值。 其实由于计算机数的表示，这种例子还有很多很多， 等哪天想起便继续补充。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"二进制","slug":"二进制","permalink":"//boyoung.me/tags/二进制/"}]},{"title":"操作系统fork()","slug":"操作系统fork()","date":"2017-04-02T08:30:08.000Z","updated":"2017-04-18T09:29:13.393Z","comments":true,"path":"2017/04/02/操作系统fork()/","link":"","permalink":"//boyoung.me/2017/04/02/操作系统fork()/","excerpt":"一道题引发的血案123int main() &#123;  fork() || fork()&#125;\n问：共创建了几个进程？\n答案为3个。现在来进行分析：","text":"一道题引发的血案123int main() &#123; fork() || fork()&#125; 问：共创建了几个进程？ 答案为3个。现在来进行分析： fork()给子进程返回一个零值，而给父进程返回一个非零值； 在main这个主进程中，首先执行 fork() || fork(), 左边的fork()返回一个非零值， 根据||的短路原则，前面的表达式为真时，后面的表达式不执行， 故包含main的这个主进程创建了一个子进程。 由于子进程会复制父进程，而且子进程会根据其返回值继续执行， 因此在子进程中， fork() ||fork()这条语句左边表达式的返回值是0, 所以||右边的表达式要执行，这时在子进程中又创建了一个进程， 即main进程-&gt;子进程-&gt;子进程，一共创建了3个进程。 接下来详细介绍fork()函数。 该篇文章的完成参考了一位博客，在此感谢。 fork入门fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程， 一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。 然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。 相当于克隆了一个自己。 先来看一个例子： 123456789101112131415161718int main () &#123; pid_t fpid; int count=0; fpid=fork(); if (fpid &lt; 0) printf(\"error in fork!\"); else if (fpid == 0) &#123; printf(\"i am the child process, my process id is %d/n\",getpid()); count++; &#125; else &#123; printf(\"i am the parent process, my process id is %d/n\",getpid()); count++; &#125; printf(\"统计结果是: %d/n\",count); return 0; &#125; 输出结果是： i am the child process, my process id is 5574 统计结果是: 1 i am the parent process, my process id is 5573 统计结果是: 1 解析：在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后， 就变成两个进程在执行了，这两个进程的几乎完全相同， 将要执行的下一条语句都是if(fpid&lt;0)…… fork把进程当前的情况拷贝了一份，执行fork时，进程已经执行完了int count = 0， fork只拷贝下一个要执行的代码到新的进程，因此不是从#include开始复制代码。 注意！！！严格来说拷贝代码是不正确，其实是父子进程共享代码，上述解释仅是便于理解。 fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： 在父进程中，fork返回新创建子进程的进程ID； 在子进程中，fork返回0； 如果出现错误，fork返回一个负值。 引用一位网友的话来解释fpid的值为什么在父子进程中不同。 “其实就相当于链表，进程形成了链表，父进程的fpid指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0。“ 创建新进程成功后，系统中出现两个基本完全相同的进程， 这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。 每个进程都有一个独特（互不相同）的进程标识符（process ID）， 可以通过getpid（）函数获得，还有一个记录父进程pid的变量， 可以通过getppid（）函数获得变量的值。 fork进阶再看一个例子： 12345678910111213141516int main(void) &#123; int i=0; printf(\"i son/pa ppid pid fpid/n\"); //ppid指当前进程的父进程pid //pid指当前进程的pid, //fpid指fork返回给当前进程的值 for(i=0;i&lt;2;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(\"%d child %4d %4d %4d/n\",i,getppid(),getpid(),fpid); else printf(\"%d parent %4d %4d %4d/n\",i,getppid(),getpid(),fpid); &#125; return 0; &#125; 输出为： 1234567i son/pa ppid pid fpid0 parent 2043 3224 32250 child 3224 3225 01 parent 2043 3224 32261 parent 3224 3225 32271 child 1 3227 01 child 1 3226 0 分析： 在父进程中，指令执行到for循环中，i=0，接着执行fork， fork执行完后，系统中出现两个进程，分别是p3224和p3225（用pxxxx表示进程id为xxxx的进程）。 可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。 用一个链表来表示这个关系：p2043-&gt;p3224-&gt;p3225 第一次fork后，p3224（父进程）的变量为i=0，fpid=3225， ​ p3225（子进程）的变量为i=0，fpid=0， 所以打印前两行结果： 120 parent 2043 3224 32250 child 3224 3225 0 接下来，假设父进程p3224先执行，当进入下一个循环时，i=1， 接着执行fork，系统中又新增一个进程p3226， 对于此时的父进程， p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）， 对于子进程p3225，执行完第一次循环后，i=1，接着执行fork，新增一个进程p3227， 对于此进程， p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。 所以打印中间两行结果： 121 parent 2043 3224 32261 parent 3224 3225 3227 第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了， 因为这两个进程无法进入第三次循环，无法fork，该执行return 0了，其他进程也是如此。 打印出结果： 121 child 1 3227 01 child 1 3226 0 但是p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？ 牵扯到进程的创建和死亡的过程， 在p3224和p3225执行完第二个循环后，main函数就该退出了， 也即进程该死亡了，因为它已经做完所有事情了。 p3224和p3225死亡后， p3226，p3227就没有父进程了，这在操作系统是不被允许的， 所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的， 为什么P1不会死亡，感兴趣可以查阅相关资料。 总结一下，这个程序执行的流程如下： 这个程序最终产生了3个子进程，执行过6次printf（）函数。 例题最后再来道例题。 123456789101112int main(void) &#123; int i=0; for(i=0;i&lt;3;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(\"son/n\"); else printf(\"father/n\"); &#125; return 0; &#125; 输出为： 1234567891011121314fathersonfatherfatherfatherfathersonsonfathersonsonsonfatherson 这里就不做详细解释了，只做一个大概的分析。 123456789for i=0 1 2 father father father son son father son son father father son son father son 其中每一行分别代表一个进程的运行打印结果。 由于调度不同，所以打印顺序不一致。 注意对于这种N次循环的情况， 并不能总结如下规律： 执行printf函数的次数为2*（1+2+4+……+2^(N-1)）次， 创建的子进程数为1+2+4+……+2^(N-1)个， 这是错误的！！！ 具体规律可以查阅资料查看详细数学推导。 同时，大家如果想测一下一个程序中到底创建了几个子进程， 最好的方法就是调用printf函数打印该进程的pid， 也即调用printf(“%d/n”,getpid());或者通过printf(“+/n”); 来判断产生了几个进程。 有人想通过调用printf(“+”);来统计创建了几个进程，这是不妥当的。 分析代码： 12345678910111213int main() &#123; pid_t fpid;//fpid表示fork函数返回的值 //printf(\"fork!\"); printf(\"fork!/n\"); fpid = fork(); if (fpid &lt; 0) printf(\"error in fork!\"); else if (fpid == 0) printf(\"I am the child process, my process id is %d/n\", getpid()); else printf(\"I am the parent process, my process id is %d/n\", getpid()); return 0; &#125; 执行结果如下： 123fork!I am the parent process, my process id is 3361I am the child process, my process id is 3362 如果把语句printf(“fork!/n”);注释掉，执行printf(“fork!”); 则新的程序的执行结果是： 12fork!I am the parent process, my process id is 3298fork!I am the child process, my process id is 3299 程序的唯一的区别就在于一个/n回车符号，但第二种fork!却被打印两次为什么呢？ 这就跟printf的缓冲机制有关了，printf某些内容时， 操作系统仅仅是把该内容放到了stdout的缓冲队列里了,并没有实际的写到屏幕上。 但是,只要看到有/n 则会立即刷新stdout,因此就马上能够打印了。 运行了printf(“fork!”)后,“fork!”仅仅被放到了缓冲里,程序运行到fork时缓冲里面的“fork!” 被子进程复制过去了。 因此在子进程度stdout缓冲里面就也有了fork! 。 所以,你最终看到的会是fork! 被printf了2次！！！！ 而运行printf(“fork! /n”)后,“fork!”被立即打印到了屏幕上,之后fork到的子进程里的stdout缓冲里不会有fork! 内容。 因此你看到的结果会是fork! 被printf了1次！！！！ 所以说printf(“+”);不能正确地反应进程的数量。 最后以一道练习题结束： 1234567int main(int argc, char* argv[]) &#123; fork(); fork() &amp;&amp; fork() || fork(); fork(); return 0; &#125; 问题是不算main这个进程自身，程序到底创建了多少个进程? 先用代码分析： 1234567int main(int argc, char* argv[]) &#123; fork(); fork() &amp;&amp; fork() || fork(); fork(); printf(\"+/n\"); &#125; 答案是总共20个进程，除去main进程，还有19个进程。 第一个fork和最后一个fork肯定是会执行的。 主要在中间3个fork上，可以画一个图进行描述。 这里就需要注意&amp;&amp;和||运算符。 A&amp;&amp;B，如果A=0，就没有必要继续执行&amp;&amp;B了；A非0，就需要继续执行&amp;&amp;B。 A||B，如果A非0，就没有必要继续执行||B了，A=0，就需要继续执行||B。 fork()对于父进程和子进程的返回值是不同的，按照上面的A&amp;&amp;B和A||B的分支进行画图，可以得出5个分支。 因此进程总数为2乘5乘2=20，减去主进程，即为19个。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"操作系统","slug":"操作系统","permalink":"//boyoung.me/tags/操作系统/"}]},{"title":"广度优先搜索","slug":"广度优先搜索","date":"2017-02-15T12:32:26.000Z","updated":"2017-03-23T09:00:05.524Z","comments":true,"path":"2017/02/15/广度优先搜索/","link":"","permalink":"//boyoung.me/2017/02/15/广度优先搜索/","excerpt":"前言广度优先搜索，又称宽度优先搜索，即BFS，是连通图的一种遍历策略。\n思想为从一个顶点开始，优先遍历较广区域。\n很多最短路径算法都是基于广度优先搜索思想得出来的。\n所谓的连通图即为每两个顶点都至少有一条路径相连。","text":"前言广度优先搜索，又称宽度优先搜索，即BFS，是连通图的一种遍历策略。 思想为从一个顶点开始，优先遍历较广区域。 很多最短路径算法都是基于广度优先搜索思想得出来的。 所谓的连通图即为每两个顶点都至少有一条路径相连。 基本思路从一个起点到一个终点，寻求一条最短的路径。 现以一个例子图来介绍该思路。（图片参照原博客主） 在搜索的过程中，初始所有节点是白色（代表了所有点都还没开始搜索）， 把起点V0标志成灰色（表示即将辐射V0），下一步搜索的时候， 我们把所有的灰色节点访问一次，然后将其变成黑色（表示已经被辐射过了）， 进而再将他们所能到达的节点标志成灰色（因为那些节点是下一步搜索的目标点了）， 但是这里有个判断，就像刚刚的例子，当访问到V1节点的时候， 它的下一个节点应该是V0和V4，但是V0已经在前面被染成黑色了，所以不会将它染灰色。 这样持续下去，直到目标节点V6被染灰色，说明了下一步就到终点了， 没必要再搜索（染色）其他节点了，此时可以结束搜索了，整个搜索就结束了。 然后根据搜索过程，反过来把最短路径找出来。 流程图如下： 两个例子第一个例子POJ3984迷宫问题 定义一个二维数组： 12345678910111213int maze5 = &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走， 不能斜着走，要求编程序找出从左上角到右下角的最短路线。 BFS的第一步就是要识别图的节点跟边。 节点就是某种状态，边就是节点与节点间的某种规则。 对应于《迷宫问题》，你可以这么认为，节点就是迷宫路上的每一个格子（非墙）， 走迷宫的时候，格子间的关系是什么呢？ 按照题目意思，我们只能横竖走，因此我们可以这样看， 格子与它横竖方向上的格子是有连通关系的，只要这个格子跟另一个格子是连通的， 那么两个格子节点间就有一条边。 如果说本题再修改成斜方向也可以走的话， 那么就是格子跟周围8个格子都可以连通，于是一个节点就会有8条边。 则对于题目的输入数组，把节点定义为(x,y)，(x,y)表示数组maze的项maze[x][y]。 于是起点就是(0,0)，终点是(4,4)。 则详细搜索步骤是不是就变为和上述BFS过程相同了呢？ 现在给出代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define MAXL 5int a[MAXL][MAXL];//迷宫//四个方向 int dir[][2] = &#123; &#123; 0, 1 &#125;,&#123; 1, 0 &#125;, &#123; 0, -1 &#125;,&#123; -1, 0 &#125;&#125;;struct Node&#123; int x;//结点横坐标 int y;//结点纵坐标 int s; //记录路径结点个数 short l[30];//记录路径方向 Node(int xx, int yy) &#123; x = xx; y = yy; &#125; Node()&#123;&#125;&#125;;bool operator == (Node &amp; no1, Node &amp; no2)&#123; if (no1.x == no2.x &amp;&amp; no1.y == no2.y) return true; else return false;&#125;bool isValid(int x, int y)&#123; if (x &lt; 0 || x &gt;= MAXL || y &lt; 0 || y &gt;= MAXL || a[x][y] == 1) return false; else return true;&#125;/*** 广度优先搜索* @param Vs 起点* @param Vd 终点*/Node BFS(Node&amp; Vs, Node&amp; Vd) &#123; queue&lt;Node&gt; Q; //用于保存路径 Node wujie(MAXL + 1, MAXL + 1); Node Vn, Vw; int i; //用于标记颜色当visit[i][j]==true时，说明节点访问过，也就是黑色 bool visit[MAXL][MAXL]; memset(visit, false, sizeof(visit)); //初始状态将起点放进队列Q Q.push(Vs); visit[Vs.x][Vs.y] = true;//设置节点已经访问过了！ while (!Q.empty()) &#123;//队列不为空，继续搜索！ //取出队列的头Vn Vn = Q.front(); Q.pop(); if (Vn == Vd) &#123;//找到终点了！ return Vn;//返回 &#125; int nx, ny; for (i = 0; i &lt; 4; ++i) &#123; nx = Vn.x + dir[i][0]; ny = Vn.y + dir[i][1];//计算相邻节点 if (isValid(nx, ny) &amp;&amp; !visit[nx][ny]) &#123; //是一个合法的节点并且为白色节点 Vw = Vn; Vw.x = nx; Vw.y = ny; Vw.s = Vn.s + 1; Vw.l[Vn.s] = i; Q.push(Vw);//加入队列Q visit[Vw.x][Vw.y] = true;//设置节点颜色 &#125; &#125; &#125; return wujie;//无解 &#125;int main()&#123; int i, j; for (i = 0; i &lt; MAXL; i++) &#123; for (j = 0; j &lt; MAXL; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; Node begin(0, 0), end(MAXL - 1, MAXL - 1); begin.s = 0; Node ans = BFS(begin, end); int x, y; x = 0, y = 0; if (ans.x &gt;= MAXL || ans.y &gt;= MAXL) &#123; printf(\"Error\\n\"); &#125; else &#123; for (i = 0; i &lt;= ans.s; i++) &#123; printf(\"(%d, %d)\\n\", x, y); x += dir[ans.l[i]][0]; y += dir[ans.l[i]][1]; &#125; &#125; return 0;&#125; 第二个例子推箱子 大家一定玩过“推箱子”这个经典的游戏。具体规则就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，请你求出玩家最少需要移动多少步才能够将游戏目标达成。 每个测试输入包含1个测试用例。第一行输入两个数字N，M表示地图的大小。其中0&lt;N，M&lt;=8。接下来有N行，每行包含M个字符表示该行地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。每个地图必定包含1个玩家、1个箱子、1个目的地。 输出一个数字表示玩家最少需要移动多少步才能将游戏目标达成。当无论如何达成不了的时候，输出-1。 此题明显也是BFS搜索问题，但不同点在于，这里要用四维数组即四维状态来表示人和箱子的位置状态。 具体代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;queue&gt;//#include&lt;istream&gt;#include&lt;string&gt;//#include&lt;stdio.h&gt;using namespace std;int state[10][10][10][10];//四维数组表示人和箱子的位置状态,开始全为0 struct q&#123; int px, py, bx, by; q(int x, int y, int bx, int by) :px(x), py(y), bx(bx), by(by) &#123;&#125;&#125;;int moves[4][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; -1,0 &#125;,&#123; 1,0 &#125; &#125;;//四个方向char map[10][10];//地图数组int chx, chy, cbx, cby, ex, ey, n, m;//分别表示当前人的位置，盒子的位置，终点位置，以及地图尺寸。 bool bound(int x, int y)//边界检查，遇到不合理的位置返回真&#123; if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m || map[x][y] == '#') return true; else return false;&#125;int bfs()&#123; state[chx][chy][cbx][cby] = 1;//当前其实状态位置设步数为1 q temp(chx, chy, cbx, cby); queue&lt;q&gt; que; //状态队列 que.push(temp);//初始状态入栈 while (que.size()) //只要队列不为空就一直寻找 &#123; temp = que.front();//获取首元素 que.pop();//首元素弹出 if (temp.bx == ex &amp;&amp; temp.by == ey) return state[temp.px][temp.py][temp.bx][temp.by] - 1;//如果箱子在终点，结束，返回步数 for (int i = 0; i &lt; 4; i++)//四个方向开始搜索了 &#123; //先更新人的位置 int px = temp.px + moves[i][0]; int py = temp.py + moves[i][1]; if (bound(px, py)) continue;//如果这个位置非法，探寻其它方向 if (px == temp.bx&amp;&amp;py == temp.by)//如果此时人的位置与箱子的位置重合，说明人应当推动了箱子 &#123; if (bound(temp.bx + moves[i][0], temp.by + moves[i][1])) continue;//如果箱子移动的位置不合法，则重新探寻其它方向 state[px][py][temp.bx + moves[i][0]][temp.by + moves[i][1]] = state[temp.px][temp.py][temp.bx][temp.by] + 1;//箱子推动，则人和箱子位置改变，记录新状态 que.push(q(px, py, temp.bx + moves[i][0], temp.by + moves[i][1]));//新状态入栈 &#125; else//人没有推动箱子 &#123; if (state[px][py][temp.bx][temp.by])//如果移动后的状态出现过，则重新搜素新方向 continue; state[px][py][temp.bx][temp.by] = state[temp.px][temp.py][temp.bx][temp.by] + 1; //没有走过这条路就走着试试 que.push(q(px, py, temp.bx, temp.by));//更新状态 &#125; &#125; &#125; return -1;//如果所有位置都试过了，没有找到，说明不存在 &#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; //cin.clear(); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", map[i]); &#125; //char x = '.'; //cout &lt;&lt; x &lt;&lt; endl; //cout &lt;&lt; map[0] &lt;&lt; endl; for (int i = 0; i &lt; n; i++)//初始化人，箱子，终点的位置 &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '*') &#123; cbx = i; cby = j; &#125; else if (map[i][j] == 'X') &#123; chx = i; chy = j; &#125; else if (map[i][j] == '@') &#123; ex = i; ey = j; &#125; &#125; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; 其实还有很多好玩的衍生趣味问题都可以用BFS来解决，希望能够去解决这些有趣的问题。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"图算法","slug":"图算法","permalink":"//boyoung.me/tags/图算法/"},{"name":"数据结构","slug":"数据结构","permalink":"//boyoung.me/tags/数据结构/"}]},{"title":"十年，老姐永恒","slug":"十年，老姐永恒","date":"2016-05-26T16:00:00.000Z","updated":"2017-06-04T13:26:45.167Z","comments":true,"path":"2016/05/27/十年，老姐永恒/","link":"","permalink":"//boyoung.me/2016/05/27/十年，老姐永恒/","excerpt":"大概上帝不希望姐姐变老。\n大概上帝想要听姐姐唱歌。\n希望姐姐永远年轻漂亮。\n希望姐姐永远坚强。\n希望自己永远坚强。\n希望老姐和zard精神不灭。","text":"大概上帝不希望姐姐变老。 大概上帝想要听姐姐唱歌。 希望姐姐永远年轻漂亮。 希望姐姐永远坚强。 希望自己永远坚强。 希望老姐和zard精神不灭。 坂井泉水，本名蒲池幸子，1967年2月6日出生于日本神奈川县平冢市， 日本乐队ZARD的主唱，日本女歌手、作词家。 1991年3月27日，随乐队发行出道EP《Good-bye My Loneliness》 ； 12月15日，随乐队发行专辑《もう探さない》，其中两首歌曲由坂井泉水作曲 。 1992年9月9日，随乐队发行单曲《IN MY ARMS TONIGHT》，该单曲为《学校があぶない》的主题曲 。 1993年6月9日，WANDS乐队主唱上杉升与坂井泉水合作作词的单曲《果てしない梦を》发行， 该歌曲于6月21日在公信榜上初登场2位 。 1996年1月8日，发行单曲《マイフレンド》发行，初上榜第1位[5] ，并成为动画片《灌篮高手》第4部片尾曲 。 2006年6月，因患子宫宫颈癌在东京庆应大学医院接受住院治疗的坂井泉水， 从来没有放弃对生的希望，她抱着“不要认输”的信念，与病魔对抗到底。 在治疗过程中 还不忘坚持歌词的创作。在摘除子宫手术之后病情一度好转， 她还计划在07年秋天发行新的专辑和举办阔别3年的演唱会，非常可惜的是这个愿望永远也无法实现了。 2007年4月坂井泉水被检查出体内的癌细胞转移到了肺部，于是再次住院接受治疗。 由于癌细胞扩散到肺部难以发声的她，还为病友唱起了[负けないで]，鼓励她不要被病魔打倒，勇敢地活下去。因为事业，泉水一生没有结婚。泉水本人非常喜欢小孩，可以说是不管走到哪里， 看到小孩都会驻足合影，在她的录象中总是出现小孩的身影。 而06年病情恶化，切除了子宫患处，不能当妈妈成了泉水一生的遗憾。 2006年的泉水生前最后一张单曲[ハートに火をつけて]的拍摄中，她穿上了婚纱。 想到泉水一生的遗憾，这张美丽的照片也让人心酸 。 “她是一个低调的，毫不张扬的人，专辑几乎没有宣传，很少参加电视节目， 从来没有过任何的负面新闻，专辑依然有相当出色的销量，单纯地用音乐来吸引听众， 对于一个艺人来说这简直是一个奇迹般的存在.这种感觉就好比是在图书馆角落里的书架上， 找到一本不为人知的小说，陈旧的封面上只有淡淡的颜色，然而书中的内容却是你一直所苦苦寻找的世界， 她就那样轻轻地震撼着你，温柔地征服着你。虽然很轻，尽管很淡，然而却足以占据整个灵魂。 她很少出现在公共场合，只有99年和04年两次演唱会。加上这两次演唱会， 她一生只参加过7次公开活动，而最后一次，是她的追悼会。” 她有出众的相貌却不穿暴露的衣服 ，不化浓妆。她不仅是有名的作词家还是日本有名的诗人。 她在绘画、插花、摄影、写作方面也有很高的造诣。 出版了四本诗集，曾为WANDS、DEEN、FOV等乐队作词， 1993年邓丽君的最后一首日语歌《与君共度一生》正是泉水为她作的词， 据说因歌词细腻温柔，十分感人，邓丽君在录音过程中被感动的数次落泪。 从20世纪90年代就开始流行的日本老牌饮料《宝矿力》的广告曲也大多是她的作品。 美国为纪念坂井泉水，特别发行了一套面值为一美元可通用的纪念货币. 2007年5月28日， 坂井泉水所属经纪公司公布坂井泉水在东京某家医院去世的消息 。 2007年6月27日，超过30度的高温，4万多人参加坂井泉水的追思会，现场被无数的鲜花装点， 歌迷中不乏老人和小孩。“在遇到挫折时，一直都被她的歌鼓励，今天来是想送她一程，表示对她的感谢” 一个歌迷说道。追思会现场，工作人员亲手发送着泉水生前为歌迷写的卡片，每张卡片上都有泉水不同的寄语。 无数人失声痛哭，歌迷们迟迟不肯离开。追思会即将结束，歌迷们一起拍手高唱《不要认输》为她送行， 并呼喊：“谢谢你，泉水！” 爱上泉水是因为她的音乐她的人格，并不知道她有如此美的容颜。 而如今，这永恒的美丽让我们深深的心痛。 一曲《负けないで》让我们奋进； 一曲《MY FRIEND》让我们感到了友谊的伟大和纯真； 一曲《心を开いて》让我们打开心扉，微笑着面对明天； 一曲《もっと近くで君の横颜见ていたい》寄托了我们深深的思念和悲痛…… 一曲《forever you 》，是永远的你，无可替代也无与伦比的你…… 我们知道，其实你一直在这里，不曾离去…… 很多失意的时候,听听泉水的歌,心情会在不知不觉中变的舒畅。 不管任何时候，都能得到她的鼓励，她的精神影响着我，改变了我的生命。 她，一个用音乐传输梦想的人，用一种最容易被接受的途径去影响世人的人， 她不是伟人，她是平凡又耀眼的坂井泉水。 虽然泉水已经离开了，但是她的乐观她的精神，一直还存在着，一直给予我们希望， 一直激励着每个人坚持自己的梦想。 而她留下的精神和人格魅力，让她完成了此生最盛大最华丽的转身，也让每个人深深的铭记。 就像她写给歌迷的话 きっと忘れない 不会忘记你 泉水姐姐，在天堂也放声歌唱 ~","raw":null,"content":null,"categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"//boyoung.me/tags/essay/"},{"name":"坂井泉水","slug":"坂井泉水","permalink":"//boyoung.me/tags/坂井泉水/"},{"name":"追忆","slug":"追忆","permalink":"//boyoung.me/tags/追忆/"}]},{"title":"坂井泉水，负けないで","slug":"坂井泉水，负けないで","date":"2016-02-10T13:07:09.000Z","updated":"2016-12-14T03:00:45.413Z","comments":true,"path":"2016/02/10/坂井泉水，负けないで/","link":"","permalink":"//boyoung.me/2016/02/10/坂井泉水，负けないで/","excerpt":"\n\n\n致敬老姐永恒今年的2月10日是zard出道的第二十五年。怀念一下泉水姐姐。非要形容老姐的话，她的「永遠」可以描述这种感觉。没有一点刺激性，泉水一般的美人，给人的感觉非常舒服。","text":"致敬老姐永恒今年的2月10日是zard出道的第二十五年。怀念一下泉水姐姐。非要形容老姐的话，她的「永遠」可以描述这种感觉。没有一点刺激性，泉水一般的美人，给人的感觉非常舒服。 出淤泥而不染，濯清涟而不妖一位笔者将老姐的美分为“天性美”、“诗性美”等，当时看完后个人而言是非常同意的。因为你可以在她身上发现男性的潇洒帅气、女性的甜美坚强、孩子的淘气心性以及成人的豁达气质。中学时期，擅长运动，精通网球和长跑，神奈川长跑比赛破女子纪录。曾在早期说自己给人的印象是冷。其实内心中是一个敏感，感情充沛的人～从她的歌词就可以看出来了。前期唱过的歌，个人非常喜欢不要认输，特别激励人心的一首歌。乐队成员在91年前后逐个离开，她一个人一直支撑着zard。对于工作，她曾经说过“从起床开始，自己的生活就和音乐紧密相关。”爱纪录生活中的一点一滴，将它们编入歌词，有很多写满记忆碎片的小本本。爱在深夜工作，早起困难户。不爱将工作局促于录音棚的空间，热爱于生活中寻找灵感。和她合作过的人，都赞叹她的敬业。对于生活，热爱摄影、油画、花环制作。经常去国外找灵感，去国外总爱流连各类画展。比较低调，几乎不参加采访和电视节目（特别是后期）。常常素颜单衣，扎着麻花。后来生病，依旧乐观。总觉得自己会康复，对病情不甚在意。后来的离开是一场意外。出淤泥而不染，濯清涟而不妖。足以形容她的一生。 音乐唱响一世无论你知不知道泉水姐姐，你必然听过她创作的歌曲。作为二次元爱好者来回答一下。中华小当家OP2《无法呼吸》（中华一番最喜欢的OP）灌篮高手ED4《My Friend》（不亚于《直到世界的尽头》的经典）名侦探柯南OP4《转动命运之轮》（最伟大的柯南片头曲之一）名侦探柯南OP15《星之光芒》名侦探柯南OP21《光辉的信念》名侦探柯南OP22《爱在黑暗中》名侦探柯南ED17《梦见明天》名侦探柯南ED24《好悲伤，却依旧喜欢你》名侦探柯南M2《仿佛回到少女时代》名侦探柯南M9《等待夏日的航帆》名侦探柯南M12《展开双翼》龙珠GT OP原作词、翻唱《DAN DAN 渐渐被你吸引龙珠GT ED《Don’t You See》 负けないで！ 简单提及一下老姐的词吧。 「もう少し，あと少し…」： きまぐれな九月の雨に（反反复复九月的雨中）白い傘の少女がすれ違う（撑着白伞的少女擦肩而过） 「負けないで」： ふとした瞬間に視線がぶつかる（偶然的一瞬间与你四目相接） 「マイ フレンド」： いつも輝いていたね 少年のまま 瞳はMy friend（少年时代 曾经一直闪耀的你的明眸 My friend）あなたを想うだけで 心は強くなれた（只要想起你 内心就会变得坚强）ずっと見つめてるから 走り続けて（我会一直注视着你 所以请继续勇往直前） 还有永远。歌词总是最能反映创作者心灵的。姐姐的声音是能给人带来希望的。这也是我喜欢听日文歌的原因。能带来共鸣。姐姐走了。大概上帝不愿意让她变老。希望姐姐永远年轻漂亮。希望姐姐永远坚强。希望自己永远坚强。希望老姐和zard精神不灭。","raw":null,"content":null,"categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"//boyoung.me/tags/essay/"},{"name":"坂井泉水","slug":"坂井泉水","permalink":"//boyoung.me/tags/坂井泉水/"},{"name":"追忆","slug":"追忆","permalink":"//boyoung.me/tags/追忆/"}]},{"title":"线性表","slug":"线性表","date":"2015-09-15T10:27:39.000Z","updated":"2017-03-22T07:15:48.133Z","comments":true,"path":"2015/09/15/线性表/","link":"","permalink":"//boyoung.me/2015/09/15/线性表/","excerpt":"何为线性表线性表的划分是从数据的逻辑结构上进行的。线性指的是在数据的逻辑结构上是线性的。即在数据元素的非空有限集中：\n(1) 存在唯一的一个被称作“第一个”的数据元素；\n(2) 存在唯一的一个被称作“最后一个”的数据元素；\n(3) 除第一个外，集合中的每个数据元素均只有一个前继元素；\n(4) 除最后一个外，集合中的每个数据元素均只有一个后继元素。","text":"何为线性表线性表的划分是从数据的逻辑结构上进行的。线性指的是在数据的逻辑结构上是线性的。即在数据元素的非空有限集中： (1) 存在唯一的一个被称作“第一个”的数据元素； (2) 存在唯一的一个被称作“最后一个”的数据元素； (3) 除第一个外，集合中的每个数据元素均只有一个前继元素； (4) 除最后一个外，集合中的每个数据元素均只有一个后继元素。 对于线性表，从存储结构上分，可以分为顺序存储结构和链式存储结构。 结构如下： 定义线性表基本的变量和结构体： 1234567891011121314151617181920212223242526272829303132333435#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASTABLE -1#define OVERFLOW -2#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量#define LISTINCREMENT 10 // 线性表存储空间的初始分配量typedef int status;typedef struct Book ElemType; //定义数据类型变量typedef struct&#123; ElemType * elem; int length; int listsize;&#125;SqList; //定义线性表/**&lt; 对数据类型进行定义 */typedef struct&#123; int item1;&#125;BElemtype;typedef struct LinkList&#123; BElemtype elem; struct LinkList *next;&#125;LinkList;struct Book&#123; char name[50]; LinkList *head;&#125;; 顺序存储结构实现线性表构造一个空的线性表： 12345678status InitList(SqList *L)&#123; L-&gt;elem = (ElemType *)malloc( LIST_INIT_SIZE * sizeof (ElemType)); if(!L-&gt;elem) exit(OVERFLOW); L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; return OK;&#125; 销毁线性表L： 123456789status DestroyList(SqList *L)&#123; if(!L-&gt;elem) exit(OVERFLOW); free(L-&gt;elem); L-&gt;elem = NULL; L-&gt;length = 0; L-&gt;listsize = 0; return OK;&#125; 将L重置为空表： 123456789status ClearList(SqList *L)&#123; free(L-&gt;elem); L-&gt;elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof (ElemType)); if(!L-&gt;elem) exit(OVERFLOW); L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; return OK;&#125; 若L为空表，则返回TRUE,否则返回FALSE： 123456status ListEmpty(SqList L)&#123; if(L.elem == NULL) return ERROR; if(L.length == 0) return TRUE; else return FALSE ;&#125; 用e返回L中第i个数据元素的值： 123456789status GetElem(SqList L, int i, ElemType *e)&#123; if(1 &lt;= i &amp;&amp; i &lt;= L.length)&#123; *e = L.elem[i-1]; return OK; &#125; else&#123; return ERROR; &#125;&#125; 返回L中第1个与e满足关系compare（）关系的数据元素的位序： 1234567891011int LocateElem(SqList L, ElemType e, status (*compare)(ElemType e1, ElemType e2))&#123; if(L.elem==NULL) return ERROR; int i; for(i=L.length ; i&gt;0 ; i--) &#123; if(compare(e,L.elem[i-1])) return i; &#125; return 0; //不存在则返回0&#125; 若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义： 123456789101112status PriorElem(SqList L,ElemType cur_e,ElemType *pre_e)&#123; int e_now; e_now = LocateElem(L, cur_e, equal); if(e_now &gt; 1)&#123; *pre_e = L.elem[e_now - 2]; return OK; &#125; else&#123; printf(\"The element is the first one of the list.And so the pre_e is not defined.\"); return ERROR; &#125;&#125; 若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义： 12345678910status NextElem(SqList L,ElemType cur_e,ElemType *next_e)&#123; if(L.elem==NULL) return ERROR; int i ; i = LocateElem(L,cur_e,equal); if(i&lt;=1) return ERROR; else *next_e=L.elem[i] ; return OK;&#125; 在L的第i个位置之前插入新的数据元素e，L的长度加1： 123456789101112131415161718192021status ListInsert(SqList *L,int i,ElemType e)&#123; if(i &lt; 1 || i &gt; L-&gt;length + 1) return ERROR; if(L-&gt;length &gt;= L-&gt;listsize)&#123; ElemType * newbase; newbase = (ElemType *)realloc(L-&gt;elem, (L-&gt;listsize + LISTINCREMENT) * sizeof(ElemType)); if(!newbase)&#123; exit(OVERFLOW); &#125; L-&gt;elem = newbase; L-&gt;listsize += LISTINCREMENT; &#125; ElemType *p; ElemType *q; q = &amp;(L-&gt;elem[i-1]); for(p = &amp;(L-&gt;elem[L-&gt;length - 1]); p &gt;= q; --p) *(p+1) = *p; *q = e; ++L-&gt;length; return OK;&#125; 删除L的第i个数据元素，用e返回其值，L的长度减1： 12345678910status ListDelete(SqList *L,int i,ElemType *e)&#123; if(L-&gt;elem==NULL) return ERROR; if(i&lt;1||i&gt;L-&gt;length) return ERROR; for(;i&lt;L-&gt;length;i++) &#123; L-&gt;elem[i-1]=L-&gt;elem[i]; &#125; --L-&gt;length; return OK;&#125; 依次对L的每个数据元素调用函数visit()。一旦调用失败，则操作失败： 123456789status ListTrabverse(SqList L, void (*visit)(ElemType e))&#123; int i; if(!L.length) return ERROR; printf(\"\\n-----------all elements -----------------------\\n\"); for(i=0;i&lt;L.length;i++) visit(L.elem[i]); printf(\"\\n------------------ end ------------------------\\n\"); return OK;&#125; 将文件中内容读取至构造的线性表中： 12345678910111213141516171819status ReadFile(char path[], SqList *L)&#123; if(L-&gt;elem==NULL) return ERROR; FILE *pfile = fopen(path, \"r\"); if(pfile==NULL) &#123; printf(\"\\n----warning:数据文件打开失败\\n\"); return ERROR; &#125; fscanf(pfile, \"%d\", &amp;(L-&gt;listsize)); L-&gt;elem = (ElemType *)malloc(L-&gt;listsize*sizeof(ElemType)); if(!L-&gt;elem) return OVERFLOW; fgetc(pfile); fscanf(pfile, \"%d\", &amp;(L-&gt;length)); fgetc(pfile); fread(L-&gt;elem, sizeof(ElemType), L-&gt;listsize, pfile); fclose(pfile); return OK;&#125; 将录入的线性表中内容保存至文件中： 123456789101112131415161718status SaveFile(char path[], SqList *L)&#123; if(L-&gt;elem==NULL) return ERROR; FILE *pfile = fopen(path, \"w+\"); if(pfile==NULL) &#123; printf(\"--------%40s--------\\n\",\"warning:存储文件打开失败\"); return ERROR; &#125; fputc(' ', pfile); fprintf(pfile, \"%d\", L-&gt;listsize); fputc(' ', pfile); fprintf(pfile, \"%d\", L-&gt;length); fputc(' ', pfile); fwrite(L-&gt;elem, sizeof(ElemType), L-&gt;listsize, pfile); fclose(pfile); return OK;&#125; 链式存储结构实现线性表采用带表头结点的单链表作为线性表的物理结构，实现对多个单链表实现操作。 物理结构如下： 可以借此设计个图书管理系统，数据对象为学校和书目。 学校即为上面线性表直接实现的，而书目即为链表实现。 修改下BElemType的定义为： 123typedef struct &#123; char name[50];&#125;BElemType; 其中各学校功能函数定义与描述即为上述线性表的实现。 现在来实现某学校图书馆各书目索取函数定义与描述。 构造一个空的单链表： 主要思想是新建一链表头结点，开始时指针为空，名称为空。 12345678status BInitList(LinkList **L) &#123; *L = (LinkList *)malloc(sizeof(LinkList)); if (*L == NULL) exit(OVERFLOW); (*L)-&gt;next = NULL; strcpy((*L)-&gt;elem.name, \" \"); return OK;&#125; 删除单链表： 主要思想是依次遍历链表每个节点，释放存储空间，最后使头结点为空。 123456789101112status BDestroyList(LinkList **L) &#123; LinkList *q; if (*L == NULL) return ERROR; while (*L) &#123; q = *L; *L = (*L)-&gt;next; free(q); &#125; *L = NULL; return OK;&#125; 清空单链表： 主要思想即是与破坏链表不同在于还存在头结点，因此可结合新建链表与破坏链表。 1234567status BClearList(LinkList **L) &#123; if (*L == NULL) return ERROR; BDestroyList(L); BInitList(L); return OK;&#125; 链表是否空： 主要思想即判断头结点的next是否为空。 12345678910status BListEmpty(LinkList *L) &#123; if (L) &#123; if (L-&gt;next==NULL) return TRUE; else return FALSE; &#125; else exit(OVERFLOW);&#125; 链表长度： 主要思想即添加计数变量i，依次循环遍历链表。 12345678int BListLength(LinkList *L) &#123; if (L == NULL) return ERROR; LinkList *p = L-&gt;next; int i; for (i = 0; p != NULL; i++, p = p-&gt;next); return i;&#125; 通过下标找元素： 主要思想是通过输入的数，来确定遍历链表的次数，以此找到遍历的那个元素，来访问。 12345678910status BGetElem(LinkList *L, int i, BElemType *e) &#123; LinkList *p; int j; if (i &lt; 1 || i &gt;BListLength(L)) return ERROR; p = L; for (j = 0; j&lt;i; j++, p = p-&gt;next); *e = p-&gt;elem; return OK;&#125; 通过元素找下标： 主要思想是遍历链表的过程中通过比较函数比较链表数据和输入数据来确定位置。 1234567891011int BLocateElem(LinkList *L, BElemType e, status (*compare)(BElemType e1, BElemType e2)) &#123; if (L = NULL) return ERROR; LinkList *p = L-&gt;next; int i = 1; for (; p != NULL;p=p-&gt;next,i++) &#123; if(compare(e, p-&gt;elem)) return i; &#125;&#125; 找前继： 主要思想是通过LocateElem得到输入元素的位置，再通过GetElem得到前一位置的元素。 123456789status BPriorElem(LinkList *L, BElemType cur_e, BElemType *pre_e) &#123; int e_now; e_now = BLocateElem(L, cur_e, Bequal); if (L == NULL) return ERROR; if (e_now == ERROR) return ERROR; else if (BGetElem(L, e_now - 1, pre_e) == ERROR) return ERROR; else return TRUE;&#125; 其中Bequal函数实现为： 1234status Bequal(BElemType e1, BElemType e2)&#123; return !strcpy(e1.name, e2.name);&#125; 找后继： 思想同PriorElem。 12345678910111213status BNextElem(LinkList *L, BElemType cur_e, BElemType *next_e) &#123; int e_now; e_now = BLocateElem(L, cur_e, Bequal); *next_e = L-&gt;elem; if (L = NULL) return ERROR; if (e_now == ERROR) return ERROR; else if (BGetElem(L, e_now + 1, next_e) == ERROR) return ERROR; else return TRUE;&#125; 插入元素： 主要思想是将元素插入至新开辟的一个数据空间内，再改变链表指针指向即可。 123456789101112131415161718status BListInsert(LinkList **L, int i, BElemType e) &#123; int j; LinkList *p, *pnow; if (i &lt; 1 || i &gt; BListLength(*L) + 1) return ERROR; pnow = (LinkList*)malloc(sizeof(LinkList)); pnow-&gt;elem = e; if (!pnow) exit(-1); p = *L; for (j=0; p != NULL; p = p-&gt;next, j++) &#123; if (j == i - 1) &#123; pnow-&gt;next = p-&gt;next; p-&gt;next = pnow; &#125; &#125; return OK;&#125; 删除元素： 主要思想是通过i遍历链表到该位置，通过e保存该数据，再free掉该指针所指向空间即可。 123456789101112131415status BListDelete(LinkList *L, int i, BElemType *e) &#123; LinkList *p,*q; int j; if (i &lt; 1 || i &gt; BListLength(L)) return ERROR; p = L; for (j = 1; j &lt; i; j++) p = p-&gt;next; *e = p-&gt;next-&gt;elem; q = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; //p = p-&gt;next; free(q); return OK;&#125; 至此，基本的函数就完成了。 其中有一个易错点就是通过线性表来获取链表头结点，即通过学校进入图书馆。 先给出我的程序基本菜单： 也即为六号功能。 实现如下： 12345678910111213141516case 6: if (Bflag) break; printf(\"\\n-----请输入学校号：\"); scanf(\"%d\", &amp;i); if (GetElem(L, i) == OK) &#123; BB = &amp;(L.elem[i - 1].head); printf(\"查询成功，学校名为%s!\\n\", L.elem[i-1].name); Bflag = 1; &#125; else printf(\"Wrong.Please input the i again.\"); getchar(); getchar(); break; 线性表的操作便完全介绍完啦。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"数据结构","slug":"数据结构","permalink":"//boyoung.me/tags/数据结构/"}]},{"title":"数据结构概念总览","slug":"数据结构概念总览","date":"2015-09-10T11:03:09.000Z","updated":"2017-03-21T06:39:55.101Z","comments":true,"path":"2015/09/10/数据结构概念总览/","link":"","permalink":"//boyoung.me/2015/09/10/数据结构概念总览/","excerpt":"计算机技术计算机技术的两大支柱：1是数据结构，2是算法。\n因此毫不夸张的在某种程度上讲，程序设计等同于设计数据结构+算法。","text":"计算机技术计算机技术的两大支柱：1是数据结构，2是算法。 因此毫不夸张的在某种程度上讲，程序设计等同于设计数据结构+算法。 数据的逻辑结构线性结构的逻辑特征：有且仅有一个开始结点和终端结点，并且所有结点最多只有一个直接前驱和直接后继。如：线性表、栈、队列。 非线性结构的逻辑特征：一个结点可能有0、1、或多个直接前驱，直接后继。如：树、图、网、集合。 数据的存储结构顺序存储方法：把逻辑上相邻的结点存储在物理位置上相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。 链接存储方法：不要求逻辑上相邻的结点在物理位置上也相邻，结点间的逻辑关系由附加的指针字段表示。 索引存储方法：在存储结点信息的同时，还建立附加的索引表。 散列存储方法：根据结点的关键字直接计算出该结点的存储地址。 简易分类线性表是一种逻辑结构，若采用顺序方法的存储表示，则为顺序表；若采用链接方法的存储表示，则为链表；若采用散列方法的存储表示，则为散列表；若对线性表上的插入、删除运算限制在表的一端进行，则为栈；若对插入限制在表的一端进行，而删除限制在表的另一端进行，则为队列。","raw":null,"content":null,"categories":[],"tags":[{"name":"卖萌打滚求offer","slug":"卖萌打滚求offer","permalink":"//boyoung.me/tags/卖萌打滚求offer/"},{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"数据结构","slug":"数据结构","permalink":"//boyoung.me/tags/数据结构/"}]},{"title":"VS中scanf函数说明","slug":"VS中scanf函数说明","date":"2015-08-02T11:51:45.000Z","updated":"2016-12-11T13:11:29.636Z","comments":true,"path":"2015/08/02/VS中scanf函数说明/","link":"","permalink":"//boyoung.me/2015/08/02/VS中scanf函数说明/","excerpt":"众所周知，由于安全原因，vs2012版本及其以上会出现scanf函数报错的情形，编译时便会提示如下错误","text":"众所周知，由于安全原因，vs2012版本及其以上会出现scanf函数报错的情形，编译时便会提示如下错误： error C4996: ‘scanf’: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. 错误解释： 微软该种类型报错主要因为那些C库的函数，很多函数内部是不进行参数检测的（包括越界类的），微软担心使用这些会造成内存异常，所以就改写了同样功能的函数，改写了的函数进行了参数的检测，使用这些新的函数会更安全和便捷。关于这些改写的函数你不用专门去记忆，因为编译器对于每个函数在给出警告时，都会告诉你相应的安全函数，查看警告信息就可以获知，在使用时也再查看一下MSDN详细了解。 一般来说，直接解决该问题方法有三种：方法一：将原来的旧函数替换成新的 Security CRT functions，即替换成为新的函数scanf_s，但是scanf_s函数比scanf函数多了一个参数，即读取个数参数。例如scanf从输入流中读取一个字符类型字节,scanf(“%c”,&amp;ch),则若使用scanf_s需改为scanf_s(“%c”,&amp;ch,1); 方法二：以下方法的原理为屏蔽这个错误： 在预编译头文件stdafx.h里（注意：一定要在没有include任何头文件之前）定义下面的宏： #define _CRT_SECURE_NO_DEPRECATE 或声明 #param warning(disable:4996) 更改预处理定义： 项目-&gt;属性-&gt;配置属性-&gt;C/C++ -&gt; 预处理器 -&gt; 预处理器定义，增加： _CRT_SECURE_NO_DEPRECATE 第三种注意更改预处理定义时若在最后面加上该句话，需在这句话前面即未加之前最后面加上一个分号（在英文输入法模式下）。 方法三：方法二没有使用更加安全的 CRT 函数，显然不是一个值得推荐的好方法，但我们又不想一个一个地改函数名，这里还有一个更简便的方法： 在预编译头文件 stdafx.h 里（同样要在没有include任何头文件之前）定义下面的宏： #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1 在链接的时候便会自动将旧函数替换成 Security CRT functions 。 注意：这个方法虽然使用了新的函数，但是不能消除警告，你还得同时使用方法二(-_-)。即实际应在预编译头文件 stdafx.h 里加入下面两句： #define _CRT_SECURE_NO_DEPRECATE #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1 虽然解决了该报错问题，但是很多童鞋会发现运行时，scanf函数虽然并未报错，即该程序正确执行，但是在输入时，会发现scanf函数跳过输入字符的原因，即你没有办法输入的问题，这是为什么呢？ 因为scanf只是读入一个字符,而你在输入时实际上输入的是:字符+回车(Enter),Enter产生的”\\n”也在输入缓冲区中,下次调用 scanf时就会直接读到 它而不是等待你再次输入!所以我们不提倡使用 scanf(“%c”, …),特别是不提倡把它用在循环中。这也是微软改写该类函数的原因，那么如何解决呢？ 一把来说，主要方法有四种：方法一：只要再加一句scanf就行了。 方法二：使用函数fflush，清除流，就是在每个接收字符的scanf语句前面,加上fflush(stdin); 方法三：将 scanf(“%c”, &amp;ch); 修改为: scanf(“ %c”, &amp;ch); /在%前加上一个空格/ 方法四：将 scanf(“%c”, &amp;ch); 修改为: scanf(“%c%c”, &amp;ch); %c是跳过一个输入字符的意思.这个是scanf的一个语法.就是在%和格式字符之间加一个号就可以跳过这个输入数字.比如当执行语句:scanf(“%c,%c,%c”,&amp;a,&amp;b);时,我输入m,n,p三个字母后,a的值为m,b值为p,n被跳过了。","raw":null,"content":null,"categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"}]},{"title":"Hexo博客","slug":"Hexo博客","date":"2015-07-11T13:07:09.000Z","updated":"2017-03-20T11:58:27.845Z","comments":true,"path":"2015/07/11/Hexo博客/","link":"","permalink":"//boyoung.me/2015/07/11/Hexo博客/","excerpt":"Hexo博客初建闲来无事，便打算给自己做一个个人网站，用于分享知识、记录心情的个人小站，最后喜欢上了hexo，这是初衷。","text":"Hexo博客初建闲来无事，便打算给自己做一个个人网站，用于分享知识、记录心情的个人小站，最后喜欢上了hexo，这是初衷。 具体的搭建方法也是参考的别人，具体详见使用hexo搭建个人网站。 我使用的主题为yelee，简洁、美观而又大方。具体的可以详细搜索做这个主题前端的大佬，可以详细参考下。 博客搭建好后，还可以绑定自己的域名，我使用的域名boyoung.me便是从阿里云购买的，详细绑定方法见GitHub Pages 绑定来自阿里云的域名。 Hexo简单使用1、new hexo new [layout] 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 2、generate hexo g 生成静态文件。 3、server hexo s 启动服务器。 4、deploy hexo g 部署网站。 5、clean hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。","raw":null,"content":null,"categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"//boyoung.me/tags/blog/"},{"name":"环境搭配","slug":"环境搭配","permalink":"//boyoung.me/tags/环境搭配/"},{"name":"Hexo起始","slug":"Hexo起始","permalink":"//boyoung.me/tags/Hexo起始/"}]},{"title":"Hello Future","slug":"Hello-Future","date":"2015-07-10T04:10:26.000Z","updated":"2016-12-12T12:46:08.810Z","comments":true,"path":"2015/07/10/Hello-Future/","link":"","permalink":"//boyoung.me/2015/07/10/Hello-Future/","excerpt":"撒花撒花，博客搭好，当然要立一些flags啦！希望这个hexo博客能让我更加进步！","text":"撒花撒花，博客搭好，当然要立一些flags啦！希望这个hexo博客能让我更加进步！ About MeCollege Huazhong University of Science and Technology. Hobby Tennis, Music, Reading. Dream? Flags! Le vent se lève, il faut tenter de vivre. Maxim 以最小的代价完成生命各个维度的尝试。","raw":null,"content":null,"categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"//boyoung.me/tags/essay/"}]}]}