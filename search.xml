<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[操作系统fork()]]></title>
      <url>//boyoung.me/2017/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Ffork()/</url>
      <content type="html"><![CDATA[<h2 id="一道题引发的血案"><a href="#一道题引发的血案" class="headerlink" title="一道题引发的血案"></a>一道题引发的血案</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fork() || fork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问：共创建了几个进程？</p>
<p>答案为3个。现在来进行分析：<a id="more"></a></p>
<p>fork()给子进程返回一个零值，而给父进程返回一个非零值；</p>
<p>在main这个主进程中，首先执行<strong> <del>fork()</del> </strong> || fork(), 左边的fork()返回一个非零值，</p>
<p>根据||的短路原则，前面的表达式为真时，后面的表达式不执行，</p>
<p>故包含main的这个主进程创建了一个子进程。</p>
<p>由于子进程会复制父进程，而且子进程会根据其返回值继续执行，</p>
<p>因此在子进程中，<strong> <del>fork()</del> </strong>||fork()这条语句左边表达式的返回值是0, </p>
<p>所以||右边的表达式要执行，这时在子进程中又创建了一个进程，</p>
<p>即main进程-&gt;子进程-&gt;子进程，一共创建了3个进程。</p>
<p>接下来详细介绍fork()函数。</p>
<p>该篇文章的完成参考了<a href="http://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html" target="_blank" rel="external">一位博客</a>，在此感谢。</p>
<h2 id="fork入门"><a href="#fork入门" class="headerlink" title="fork入门"></a>fork入门</h2><p>fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，</p>
<p>一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。</p>
<p>然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。</p>
<p>相当于克隆了一个自己。</p>
<p>先来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; </span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    fpid=fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<p>i am the child process, my process id is 5574</p>
<p>统计结果是: 1</p>
<p>i am the parent process, my process id is 5573</p>
<p>统计结果是: 1</p>
<p>解析：在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，</p>
<p>就变成两个进程在执行了，这两个进程的几乎完全相同，</p>
<p>将要执行的下一条语句都是if(fpid&lt;0)……</p>
<p>fork把进程当前的情况拷贝了一份，执行fork时，进程已经执行完了int count = 0，</p>
<p>fork只拷贝下一个要执行的代码到新的进程，因此不是从#include开始复制代码。</p>
<p>注意！！！严格来说拷贝代码是不正确，其实是父子进程共享代码，上述解释仅是便于理解。</p>
<p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>
<ol>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值。</li>
</ol>
<p>引用一位网友的话来解释fpid的值为什么在父子进程中不同。</p>
<p>“其实就相当于链表，进程形成了链表，父进程的fpid指向子进程的进程id,</p>
<p>因为子进程没有子进程，所以其fpid为0。“</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，</p>
<p>这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p>
<p>每个进程都有一个独特（互不相同）的进程标识符（process ID），</p>
<p>可以通过getpid（）函数获得，还有一个记录父进程pid的变量，</p>
<p>可以通过getppid（）函数获得变量的值。</p>
<h2 id="fork进阶"><a href="#fork进阶" class="headerlink" title="fork进阶"></a>fork进阶</h2><p>再看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"i son/pa ppid pid  fpid/n"</span>);  </span><br><span class="line">   <span class="comment">//ppid指当前进程的父进程pid  </span></span><br><span class="line">   <span class="comment">//pid指当前进程的pid,  </span></span><br><span class="line">   <span class="comment">//fpid指fork返回给当前进程的值  </span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  </span><br><span class="line">       <span class="keyword">pid_t</span> fpid=fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%d child  %4d %4d %4d/n"</span>,i,getppid(),getpid(),fpid);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%d parent %4d %4d %4d/n"</span>,i,getppid(),getpid(),fpid);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i son/pa ppid pid  fpid</span><br><span class="line"><span class="number">0</span> parent <span class="number">2043</span> <span class="number">3224</span> <span class="number">3225</span></span><br><span class="line"><span class="number">0</span> child  <span class="number">3224</span> <span class="number">3225</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span> parent <span class="number">2043</span> <span class="number">3224</span> <span class="number">3226</span></span><br><span class="line"><span class="number">1</span> parent <span class="number">3224</span> <span class="number">3225</span> <span class="number">3227</span></span><br><span class="line"><span class="number">1</span> child     <span class="number">1</span> <span class="number">3227</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span> child     <span class="number">1</span> <span class="number">3226</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li><p>在父进程中，指令执行到for循环中，i=0，接着执行fork，</p>
<p>fork执行完后，系统中出现两个进程，分别是p3224和p3225（用pxxxx表示进程id为xxxx的进程）。</p>
<p>可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。</p>
<p>用一个链表来表示这个关系：p2043-&gt;p3224-&gt;p3225 </p>
<p>第一次fork后，p3224（父进程）的变量为i=0，fpid=3225，</p>
<p>​              p3225（子进程）的变量为i=0，fpid=0，</p>
<p>所以打印前两行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> parent <span class="number">2043</span> <span class="number">3224</span> <span class="number">3225</span></span><br><span class="line"><span class="number">0</span> child  <span class="number">3224</span> <span class="number">3225</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，假设父进程p3224先执行，当进入下一个循环时，i=1，</p>
<p>接着执行fork，系统中又新增一个进程p3226，</p>
<p>对于此时的父进程，</p>
<p>p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程），</p>
<p>对于子进程p3225，执行完第一次循环后，i=1，接着执行fork，新增一个进程p3227，</p>
<p>对于此进程，</p>
<p>p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。</p>
<p>所以打印中间两行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> parent <span class="number">2043</span> <span class="number">3224</span> <span class="number">3226</span></span><br><span class="line"><span class="number">1</span> parent <span class="number">3224</span> <span class="number">3225</span> <span class="number">3227</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，</p>
<p>因为这两个进程无法进入第三次循环，无法fork，该执行return 0了，其他进程也是如此。</p>
<p>打印出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> child     <span class="number">1</span> <span class="number">3227</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span> child     <span class="number">1</span> <span class="number">3226</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>但是p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？</p>
<p>牵扯到进程的创建和死亡的过程，</p>
<p>在p3224和p3225执行完第二个循环后，main函数就该退出了，</p>
<p>也即进程该死亡了，因为它已经做完所有事情了。</p>
<p>p3224和p3225死亡后，</p>
<p>p3226，p3227就没有父进程了，这在操作系统是不被允许的，</p>
<p>所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，</p>
<p>为什么P1不会死亡，感兴趣可以查阅相关资料。</p>
</li>
</ol>
<p>总结一下，这个程序执行的流程如下：</p>
<p><img src="/images/20170402/1.gif" alt=""></p>
<p>这个程序最终产生了3个子进程，执行过6次printf（）函数。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>最后再来道例题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">       <span class="keyword">pid_t</span> fpid=fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"son/n"</span>);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"father/n"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">father</span><br><span class="line">son</span><br><span class="line">father</span><br><span class="line">father</span><br><span class="line">father</span><br><span class="line">father</span><br><span class="line">son</span><br><span class="line">son</span><br><span class="line">father</span><br><span class="line">son</span><br><span class="line">son</span><br><span class="line">son</span><br><span class="line">father</span><br><span class="line">son</span><br></pre></td></tr></table></figure>
<p>这里就不做详细解释了，只做一个大概的分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>        i=<span class="number">0</span>         <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">          father     father     father</span><br><span class="line">                               	son</span><br><span class="line">                       son       father</span><br><span class="line">                                   son</span><br><span class="line">           son       father     father</span><br><span class="line">                                   son</span><br><span class="line">                      	son      father</span><br><span class="line">                                   son</span><br></pre></td></tr></table></figure>
<p>其中每一行分别代表一个进程的运行打印结果。</p>
<p>由于调度不同，所以打印顺序不一致。</p>
<p>注意对于这种N次循环的情况，</p>
<p>并不能总结如下规律：</p>
<p>执行printf函数的次数为<del>2*（1+2+4+……+2^(N-1)）</del>次，</p>
<p>创建的子进程数为<del>1+2+4+……+2^(N-1)</del>个，</p>
<p>这是错误的！！！</p>
<p>具体规律可以查阅资料查看详细数学推导。</p>
<p>同时，大家如果想测一下一个程序中到底创建了几个子进程，</p>
<p>最好的方法就是调用printf函数打印该进程的pid，</p>
<p>也即调用printf(“%d/n”,getpid());或者通过printf(“+/n”);</p>
<p>来判断产生了几个进程。</p>
<p>有人想通过调用printf(“+”);来统计创建了几个进程，这是不妥当的。</p>
<p>分析代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">pid_t</span> fpid;<span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="comment">//printf("fork!");  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork!/n"</span>);  </span><br><span class="line">    fpid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am the child process, my process id is %d/n"</span>, getpid());  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am the parent process, my process id is %d/n"</span>, getpid());  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fork!</span><br><span class="line">I am the parent process, my process id is <span class="number">3361</span></span><br><span class="line">I am the child process, my process id is <span class="number">3362</span></span><br></pre></td></tr></table></figure>
<p>如果把语句printf(“fork!/n”);注释掉，执行printf(“fork!”);</p>
<p>则新的程序的执行结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fork!I am the parent process, my process id is <span class="number">3298</span></span><br><span class="line">fork!I am the child process, my process id is <span class="number">3299</span></span><br></pre></td></tr></table></figure>
<p>程序的唯一的区别就在于一个/n回车符号，但第二种fork!却被打印两次为什么呢？</p>
<p>这就跟printf的缓冲机制有关了，printf某些内容时，</p>
<p>操作系统仅仅是把该内容放到了stdout的缓冲队列里了,并没有实际的写到屏幕上。</p>
<p>但是,只要看到有/n 则会立即刷新stdout,因此就马上能够打印了。</p>
<p>运行了printf(“fork!”)后,“fork!”仅仅被放到了缓冲里,程序运行到fork时缓冲里面的“fork!”  被子进程复制过去了。</p>
<p>因此在子进程度stdout缓冲里面就也有了fork! 。</p>
<p>所以,你最终看到的会是fork!  被printf了2次！！！！</p>
<p>而运行printf(“fork! /n”)后,“fork!”被立即打印到了屏幕上,之后fork到的子进程里的stdout缓冲里不会有fork! 内容。</p>
<p>因此你看到的结果会是fork! 被printf了1次！！！！</p>
<p>所以说printf(“+”);不能正确地反应进程的数量。</p>
<p>最后以一道练习题结束：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">   fork();  </span><br><span class="line">   fork() &amp;&amp; fork() || fork();  </span><br><span class="line">   fork();  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是不算main这个进程自身，程序到底创建了多少个进程?</p>
<p>先用代码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">   fork();  </span><br><span class="line">   fork() &amp;&amp; fork() || fork();  </span><br><span class="line">   fork();  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"+/n"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是总共20个进程，除去main进程，还有19个进程。</p>
<p>第一个fork和最后一个fork肯定是会执行的。</p>
<p>主要在中间3个fork上，可以画一个图进行描述。</p>
<p>这里就需要注意&amp;&amp;和||运算符。</p>
<p>A&amp;&amp;B，如果A=0，就没有必要继续执行&amp;&amp;B了；A非0，就需要继续执行&amp;&amp;B。</p>
<p>A||B，如果A非0，就没有必要继续执行||B了，A=0，就需要继续执行||B。</p>
<p>fork()对于父进程和子进程的返回值是不同的，按照上面的A&amp;&amp;B和A||B的分支进行画图，可以得出5个分支。</p>
<p><img src="/images/20170402/2.gif" alt=""></p>
<p>因此进程总数为2乘5乘2=20，减去主进程，即为19个。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[广度优先搜索]]></title>
      <url>//boyoung.me/2017/02/15/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>广度优先搜索，又称宽度优先搜索，即BFS，是连通图的一种遍历策略。</p>
<p>思想为从一个顶点开始，优先遍历较广区域。</p>
<p>很多最短路径算法都是基于广度优先搜索思想得出来的。</p>
<p>所谓的连通图即为每两个顶点都至少有一条路径相连。<a id="more"></a></p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>从一个起点到一个终点，寻求一条最短的路径。</p>
<p>现以一个例子图来介绍该思路。（图片参照<a href="http://blog.csdn.net/raphealguo/article/details/7523411" target="_blank" rel="external">原博客主</a>）</p>
<p><img src="/images/20170215/1.png" alt=""></p>
<p>在搜索的过程中，初始所有节点是白色（代表了所有点都还没开始搜索），</p>
<p>把起点V0标志成灰色（表示即将辐射V0），下一步搜索的时候，</p>
<p>我们把所有的灰色节点访问一次，然后将其变成黑色（表示已经被辐射过了），</p>
<p>进而再将他们所能到达的节点标志成灰色（因为那些节点是下一步搜索的目标点了），</p>
<p>但是这里有个判断，就像刚刚的例子，当访问到V1节点的时候，</p>
<p>它的下一个节点应该是V0和V4，但是V0已经在前面被染成黑色了，所以不会将它染灰色。</p>
<p>这样持续下去，直到目标节点V6被染灰色，说明了下一步就到终点了，</p>
<p>没必要再搜索（染色）其他节点了，此时可以结束搜索了，整个搜索就结束了。</p>
<p>然后根据搜索过程，反过来把最短路径找出来。</p>
<p>流程图如下：</p>
<p><img src="/images/20170215/2.png" alt=""></p>
<h2 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h2><p>第一个例子<a href="http://poj.org/problem?id=3984" target="_blank" rel="external">POJ3984迷宫问题</a></p>
<p>定义一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maze5 = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，</p>
<p>不能斜着走，要求编程序找出从左上角到右下角的最短路线。 </p>
<p>BFS的第一步就是要识别图的节点跟边。</p>
<p>节点就是某种状态，边就是节点与节点间的某种规则。</p>
<p>对应于《迷宫问题》，你可以这么认为，节点就是迷宫路上的每一个格子（非墙），</p>
<p>走迷宫的时候，格子间的关系是什么呢？</p>
<p>按照题目意思，我们只能横竖走，因此我们可以这样看，</p>
<p>格子与它横竖方向上的格子是有连通关系的，只要这个格子跟另一个格子是连通的，</p>
<p>那么两个格子节点间就有一条边。</p>
<p>如果说本题再修改成斜方向也可以走的话，</p>
<p>那么就是格子跟周围8个格子都可以连通，于是一个节点就会有8条边。</p>
<p>则对于题目的输入数组，把节点定义为(x,y)，(x,y)表示数组maze的项maze[x][y]。</p>
<p>于是起点就是(0,0)，终点是(4,4)。</p>
<p>则详细搜索步骤是不是就变为和上述BFS过程相同了呢？</p>
<p>现在给出代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXL 5</span><br><span class="line"></span><br><span class="line">int a[MAXL][MAXL];//迷宫</span><br><span class="line"></span><br><span class="line">//四个方向  </span><br><span class="line">int dir[][2] = &#123;</span><br><span class="line">	&#123; 0, 1 &#125;,&#123; 1, 0 &#125;,</span><br><span class="line">	&#123; 0, -1 &#125;,&#123; -1, 0 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int x;//结点横坐标</span><br><span class="line">	int y;//结点纵坐标</span><br><span class="line">	int s;	//记录路径结点个数</span><br><span class="line">	short l[30];//记录路径方向</span><br><span class="line">	Node(int xx, int yy)</span><br><span class="line">	&#123;</span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">	&#125;</span><br><span class="line">	Node()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator == (Node &amp; no1, Node &amp; no2)</span><br><span class="line">&#123;</span><br><span class="line">	if (no1.x == no2.x &amp;&amp; no1.y == no2.y)</span><br><span class="line">		return true;</span><br><span class="line">	else</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isValid(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	if (x &lt; 0 || x &gt;= MAXL || y &lt; 0 || y &gt;= MAXL || a[x][y] == 1)</span><br><span class="line">		return false;</span><br><span class="line">	else</span><br><span class="line">		return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 广度优先搜索</span><br><span class="line">* @param Vs 起点</span><br><span class="line">* @param Vd 终点</span><br><span class="line">*/</span><br><span class="line">Node BFS(Node&amp; Vs, Node&amp; Vd) &#123;</span><br><span class="line">	queue&lt;Node&gt; Q; //用于保存路径 </span><br><span class="line">	Node wujie(MAXL + 1, MAXL + 1);</span><br><span class="line">	Node Vn, Vw;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	//用于标记颜色当visit[i][j]==true时，说明节点访问过，也就是黑色  </span><br><span class="line">	bool visit[MAXL][MAXL];</span><br><span class="line">	memset(visit, false, sizeof(visit));</span><br><span class="line"></span><br><span class="line">	//初始状态将起点放进队列Q  </span><br><span class="line">	Q.push(Vs);</span><br><span class="line">	visit[Vs.x][Vs.y] = true;//设置节点已经访问过了！  </span><br><span class="line"></span><br><span class="line">	while (!Q.empty()) &#123;//队列不为空，继续搜索！  </span><br><span class="line">						//取出队列的头Vn  </span><br><span class="line">		Vn = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line"></span><br><span class="line">		if (Vn == Vd) &#123;//找到终点了！  </span><br><span class="line">			return Vn;//返回  </span><br><span class="line">		&#125;</span><br><span class="line">		int nx, ny;</span><br><span class="line">		for (i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">			nx = Vn.x + dir[i][0];</span><br><span class="line">			ny = Vn.y + dir[i][1];//计算相邻节点  </span><br><span class="line"></span><br><span class="line">			if (isValid(nx, ny) &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">				//是一个合法的节点并且为白色节点  </span><br><span class="line">				Vw = Vn;</span><br><span class="line">				Vw.x = nx;</span><br><span class="line">				Vw.y = ny;</span><br><span class="line">				Vw.s = Vn.s + 1;</span><br><span class="line">				Vw.l[Vn.s] = i;</span><br><span class="line">				Q.push(Vw);//加入队列Q  </span><br><span class="line">				visit[Vw.x][Vw.y] = true;//设置节点颜色  </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return wujie;//无解  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i = 0; i &lt; MAXL; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (j = 0; j &lt; MAXL; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Node begin(0, 0), end(MAXL - 1, MAXL - 1);</span><br><span class="line">	begin.s = 0;</span><br><span class="line">	Node ans = BFS(begin, end);</span><br><span class="line">	int x, y;</span><br><span class="line">	x = 0, y = 0;</span><br><span class="line">	if (ans.x &gt;= MAXL || ans.y &gt;= MAXL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf("Error\n");</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		for (i = 0; i &lt;= ans.s; i++) &#123;</span><br><span class="line">			printf("(%d, %d)\n", x, y);</span><br><span class="line">			x += dir[ans.l[i]][0];</span><br><span class="line">			y += dir[ans.l[i]][1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子<a href="https://www.nowcoder.com/questionTerminal/d64d259ee34141378b62e1ea4be74030" target="_blank" rel="external">推箱子</a></p>
<p>大家一定玩过“推箱子”这个经典的游戏。具体规则就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，请你求出玩家最少需要移动多少步才能够将游戏目标达成。</p>
<p>每个测试输入包含1个测试用例。<br>第一行输入两个数字N，M表示地图的大小。其中0&lt;N，M&lt;=8。<br>接下来有N行，每行包含M个字符表示该行地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。<br>每个地图必定包含1个玩家、1个箱子、1个目的地。</p>
<p>输出一个数字表示玩家最少需要移动多少步才能将游戏目标达成。当无论如何达成不了的时候，输出-1。</p>
<p>此题明显也是BFS搜索问题，但不同点在于，这里要用四维数组即四维状态来表示人和箱子的位置状态。</p>
<p>具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;istream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> state[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//四维数组表示人和箱子的位置状态,开始全为0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> q</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> px, py, bx, by;</span><br><span class="line">    q(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bx, <span class="keyword">int</span> by) :px(x), py(y), bx(bx), by(by) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">0</span>,<span class="number">1</span> &#125;,&#123; <span class="number">0</span>,<span class="number">-1</span> &#125;,&#123; <span class="number">-1</span>,<span class="number">0</span> &#125;,&#123; <span class="number">1</span>,<span class="number">0</span> &#125; &#125;;<span class="comment">//四个方向</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//地图数组</span></span><br><span class="line"><span class="keyword">int</span> chx, chy, cbx, cby, ex, ey, n, m;<span class="comment">//分别表示当前人的位置，盒子的位置，终点位置，以及地图尺寸。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//边界检查，遇到不合理的位置返回真</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= m || <span class="built_in">map</span>[x][y] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    state[chx][chy][cbx][cby] = <span class="number">1</span>;<span class="comment">//当前其实状态位置设步数为1</span></span><br><span class="line">    <span class="function">q <span class="title">temp</span><span class="params">(chx, chy, cbx, cby)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;q&gt; que; <span class="comment">//状态队列</span></span><br><span class="line">    que.push(temp);<span class="comment">//初始状态入栈</span></span><br><span class="line">    <span class="keyword">while</span> (que.size()) <span class="comment">//只要队列不为空就一直寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = que.front();<span class="comment">//获取首元素</span></span><br><span class="line">        que.pop();<span class="comment">//首元素弹出</span></span><br><span class="line">        <span class="keyword">if</span> (temp.bx == ex &amp;&amp; temp.by == ey)</span><br><span class="line">            <span class="keyword">return</span> state[temp.px][temp.py][temp.bx][temp.by] - <span class="number">1</span>;<span class="comment">//如果箱子在终点，结束，返回步数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//四个方向开始搜索了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先更新人的位置</span></span><br><span class="line">            <span class="keyword">int</span> px = temp.px + moves[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> py = temp.py + moves[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bound(px, py))</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//如果这个位置非法，探寻其它方向</span></span><br><span class="line">            <span class="keyword">if</span> (px == temp.bx&amp;&amp;py == temp.by)<span class="comment">//如果此时人的位置与箱子的位置重合，说明人应当推动了箱子</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (bound(temp.bx + moves[i][<span class="number">0</span>], temp.by + moves[i][<span class="number">1</span>]))</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//如果箱子移动的位置不合法，则重新探寻其它方向</span></span><br><span class="line">                state[px][py][temp.bx + moves[i][<span class="number">0</span>]][temp.by + moves[i][<span class="number">1</span>]] =</span><br><span class="line">                    state[temp.px][temp.py][temp.bx][temp.by] + <span class="number">1</span>;<span class="comment">//箱子推动，则人和箱子位置改变，记录新状态</span></span><br><span class="line">                que.push(q(px, py, temp.bx + moves[i][<span class="number">0</span>], temp.by + moves[i][<span class="number">1</span>]));<span class="comment">//新状态入栈</span></span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//人没有推动箱子</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (state[px][py][temp.bx][temp.by])<span class="comment">//如果移动后的状态出现过，则重新搜素新方向</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                state[px][py][temp.bx][temp.by] = state[temp.px][temp.py][temp.bx][temp.by] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//没有走过这条路就走着试试</span></span><br><span class="line">                que.push(q(px, py, temp.bx, temp.by));<span class="comment">//更新状态</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果所有位置都试过了，没有找到，说明不存在</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//cin.clear();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">map</span>[i]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//char x = '.';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//cout &lt;&lt; map[0] &lt;&lt; endl;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//初始化人，箱子，终点的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cbx = i;</span><br><span class="line">                cby = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'X'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                chx = i;</span><br><span class="line">                chy = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'@'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ex = i;</span><br><span class="line">                ey = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有很多好玩的衍生趣味问题都可以用BFS来解决，希望能够去解决这些有趣的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[坂井泉水，负けないで]]></title>
      <url>//boyoung.me/2016/02/10/%E5%9D%82%E4%BA%95%E6%B3%89%E6%B0%B4%EF%BC%8C%E8%B4%9F%E3%81%91%E3%81%AA%E3%81%84%E3%81%A7/</url>
      <content type="html"><![CDATA[<audio src="https://drive.google.com/uc?export=download&id=0B_vBhIKbNtVSd3F1Y1lzZm9SVEk" controls></audio>

<p><img src="/images/20160210/20160210.jpg" alt=""></p>
<h2 id="致敬老姐永恒"><a href="#致敬老姐永恒" class="headerlink" title="致敬老姐永恒"></a>致敬老姐永恒</h2><p>今年的2月10日是zard出道的第二十五年。<br>怀念一下泉水姐姐。<br>非要形容老姐的话，她的「永遠」可以描述这种感觉。<br>没有一点刺激性，泉水一般的美人，给人的感觉非常舒服。<a id="more"></a></p>
<h2 id="出淤泥而不染，濯清涟而不妖"><a href="#出淤泥而不染，濯清涟而不妖" class="headerlink" title="出淤泥而不染，濯清涟而不妖"></a>出淤泥而不染，濯清涟而不妖</h2><p>一位笔者将老姐的美分为“天性美”、“诗性美”等，当时看完后个人而言是非常同意的。<br>因为你可以在她身上发现男性的潇洒帅气、女性的甜美坚强、孩子的淘气心性以及成人的豁达气质。<br><img src="/images/20160210/1.jpg" alt=""><br>中学时期，擅长运动，精通网球和长跑，神奈川长跑比赛破女子纪录。<br>曾在早期说自己给人的印象是冷。<br>其实内心中是一个敏感，感情充沛的人～<br>从她的歌词就可以看出来了。<br>前期唱过的歌，个人非常喜欢不要认输，特别激励人心的一首歌。<br>乐队成员在91年前后逐个离开，她一个人一直支撑着zard。<br>对于工作，她曾经说过“从起床开始，自己的生活就和音乐紧密相关。”<br>爱纪录生活中的一点一滴，将它们编入歌词，有很多写满记忆碎片的小本本。<br>爱在深夜工作，早起困难户。<br>不爱将工作局促于录音棚的空间，热爱于生活中寻找灵感。<br>和她合作过的人，都赞叹她的敬业。<br><img src="/images/20160210/4.jpg" alt=""><br>对于生活，热爱摄影、油画、花环制作。<br>经常去国外找灵感，去国外总爱流连各类画展。<br>比较低调，几乎不参加采访和电视节目（特别是后期）。<br>常常素颜单衣，扎着麻花。<br>后来生病，依旧乐观。总觉得自己会康复，对病情不甚在意。<br>后来的离开是一场意外。<br>出淤泥而不染，濯清涟而不妖。<br>足以形容她的一生。 </p>
<h2 id="音乐唱响一世"><a href="#音乐唱响一世" class="headerlink" title="音乐唱响一世"></a>音乐唱响一世</h2><p>无论你知不知道泉水姐姐，你必然听过她创作的歌曲。<br><img src="/images/20160210/3.jpg" alt=""><br>作为二次元爱好者来回答一下。<br>中华小当家OP2《无法呼吸》（中华一番最喜欢的OP）<br>灌篮高手ED4《My Friend》（不亚于《直到世界的尽头》的经典）<br>名侦探柯南OP4《转动命运之轮》（最伟大的柯南片头曲之一）<br>名侦探柯南OP15《星之光芒》<br>名侦探柯南OP21《光辉的信念》<br>名侦探柯南OP22《爱在黑暗中》<br>名侦探柯南ED17《梦见明天》<br>名侦探柯南ED24《好悲伤，却依旧喜欢你》<br>名侦探柯南M2《仿佛回到少女时代》<br>名侦探柯南M9《等待夏日的航帆》<br>名侦探柯南M12《展开双翼》<br>龙珠GT OP原作词、翻唱《DAN DAN 渐渐被你吸引<br>龙珠GT ED《Don’t You See》</p>
<p>负けないで！</p>
<p>简单提及一下老姐的词吧。</p>
<p>「もう少し，あと少し…」：</p>
<blockquote>
<p>きまぐれな九月の雨に（反反复复九月的雨中）<br>白い傘の少女がすれ違う（撑着白伞的少女擦肩而过）</p>
</blockquote>
<p>「負けないで」：</p>
<blockquote>
<p>ふとした瞬間に視線がぶつかる（偶然的一瞬间与你四目相接）</p>
</blockquote>
<p>「マイ　フレンド」：</p>
<blockquote>
<p>いつも輝いていたね　少年のまま　瞳はMy friend（少年时代 曾经一直闪耀的你的明眸 My friend）<br>あなたを想うだけで　心は強くなれた（只要想起你 内心就会变得坚强）<br>ずっと見つめてるから　走り続けて（我会一直注视着你 所以请继续勇往直前）</p>
</blockquote>
<p>还有永远。<br>歌词总是最能反映创作者心灵的。<br>姐姐的声音是能给人带来希望的。<br>这也是我喜欢听日文歌的原因。<br>能带来共鸣。<br><img src="/images/20160210/2.jpg" alt=""><br>姐姐走了。<br>大概上帝不愿意让她变老。<br>希望姐姐永远年轻漂亮。<br>希望姐姐永远坚强。<br>希望自己永远坚强。<br>希望老姐和zard精神不灭。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线性表]]></title>
      <url>//boyoung.me/2015/09/15/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="何为线性表"><a href="#何为线性表" class="headerlink" title="何为线性表"></a>何为线性表</h2><p>线性表的划分是从数据的逻辑结构上进行的。线性指的是在数据的逻辑结构上是线性的。即在数据元素的非空有限集中：</p>
<p>(1) 存在唯一的一个被称作“第一个”的数据元素；</p>
<p>(2) 存在唯一的一个被称作“最后一个”的数据元素；</p>
<p>(3) 除第一个外，集合中的每个数据元素均只有一个前继元素；</p>
<p>(4) 除最后一个外，集合中的每个数据元素均只有一个后继元素。<a id="more"></a></p>
<p>对于线性表，从存储结构上分，可以分为顺序存储结构和链式存储结构。</p>
<p>结构如下：</p>
<p><img src="/images/20150915/1.png" alt=""></p>
<p>定义线性表基本的变量和结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASTABLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//  线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10   <span class="comment">//  线性表存储空间的初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Book ElemType; <span class="comment">//定义数据类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType * elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;     <span class="comment">//定义线性表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**&lt;</span><br><span class="line"> 对数据类型进行定义</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> item1;</span><br><span class="line">&#125;BElemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> LinkList&#123;</span><br><span class="line">    BElemtype elem;</span><br><span class="line">    <span class="keyword">struct</span> LinkList *next;</span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Book&#123;</span><br><span class="line">		<span class="keyword">char</span>  name[<span class="number">50</span>];</span><br><span class="line">		LinkList *head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="顺序存储结构实现线性表"><a href="#顺序存储结构实现线性表" class="headerlink" title="顺序存储结构实现线性表"></a>顺序存储结构实现线性表</h2><p>构造一个空的线性表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">InitList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">  L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>( LIST_INIT_SIZE * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">  <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  L-&gt;length = <span class="number">0</span>;</span><br><span class="line">  L-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁线性表L：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">DestroyList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;elem);</span><br><span class="line">    L-&gt;elem = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;listsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将L重置为空表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ClearList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;elem);</span><br><span class="line">    L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若L为空表，则返回TRUE,否则返回FALSE：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">     <span class="keyword">if</span>(L.length == <span class="number">0</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> FALSE ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用e返回L中第i个数据元素的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &lt;= i &amp;&amp; i &lt;= L.length)&#123;</span><br><span class="line">        *e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回L中第1个与e满足关系compare（）关系的数据元素的位序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L, ElemType e, status (*compare)(ElemType e1, ElemType e2))&#123;</span><br><span class="line">    if(L.elem==NULL)</span><br><span class="line">        return ERROR;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=L.length ; i&gt;0 ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(compare(e,L.elem[i-1]))</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; //不存在则返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">PriorElem</span><span class="params">(SqList L,ElemType cur_e,ElemType *pre_e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e_now;</span><br><span class="line">    e_now = LocateElem(L, cur_e, equal);</span><br><span class="line">    <span class="keyword">if</span>(e_now &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            *pre_e = L.elem[e_now - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The element is the first one of the list.And so the pre_e is not defined."</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">NextElem</span><span class="params">(SqList L,ElemType cur_e,ElemType *next_e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    i = LocateElem(L,cur_e,equal);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> *next_e=L.elem[i] ;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在L的第i个位置之前插入新的数据元素e，L的长度加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length &gt;= L-&gt;listsize)&#123;</span><br><span class="line">        ElemType * newbase;</span><br><span class="line">        newbase = (ElemType *)<span class="built_in">realloc</span>(L-&gt;elem, (L-&gt;listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;elem = newbase;</span><br><span class="line">        L-&gt;listsize += LISTINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType *p;</span><br><span class="line">    ElemType *q;</span><br><span class="line">    q = &amp;(L-&gt;elem[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L-&gt;elem[L-&gt;length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">        *(p+<span class="number">1</span>) = *p;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除L的第i个数据元素，用e返回其值，L的长度减1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length) <span class="keyword">return</span> ERROR;</span><br><span class="line">   	<span class="keyword">for</span>(;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;elem[i<span class="number">-1</span>]=L-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    --L-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次对L的每个数据元素调用函数visit()。一旦调用失败，则操作失败：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">status ListTrabverse(SqList L, void (*visit)(ElemType e))&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(!L.length) return ERROR;</span><br><span class="line">    printf("\n-----------all elements -----------------------\n");</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">        visit(L.elem[i]);</span><br><span class="line">    printf("\n------------------ end ------------------------\n");</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将文件中内容读取至构造的线性表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ReadFile</span><span class="params">(<span class="keyword">char</span> path[], SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    FILE *pfile = fopen(path, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfile==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n----warning:数据文件打开失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(pfile, <span class="string">"%d"</span>, &amp;(L-&gt;listsize));</span><br><span class="line">    L-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(L-&gt;listsize*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;elem)</span><br><span class="line">       <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    fgetc(pfile);</span><br><span class="line">    <span class="built_in">fscanf</span>(pfile, <span class="string">"%d"</span>, &amp;(L-&gt;length));</span><br><span class="line">    fgetc(pfile);</span><br><span class="line">    fread(L-&gt;elem, <span class="keyword">sizeof</span>(ElemType), L-&gt;listsize, pfile);</span><br><span class="line">    fclose(pfile);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将录入的线性表中内容保存至文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">SaveFile</span><span class="params">(<span class="keyword">char</span> path[], SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;elem==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    FILE *pfile = fopen(path, <span class="string">"w+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfile==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------%40s--------\n"</span>,<span class="string">"warning:存储文件打开失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    <span class="built_in">fprintf</span>(pfile, <span class="string">"%d"</span>, L-&gt;listsize);</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    <span class="built_in">fprintf</span>(pfile, <span class="string">"%d"</span>, L-&gt;length);</span><br><span class="line">    fputc(<span class="string">' '</span>, pfile);</span><br><span class="line">    fwrite(L-&gt;elem, <span class="keyword">sizeof</span>(ElemType), L-&gt;listsize, pfile);</span><br><span class="line"></span><br><span class="line">    fclose(pfile);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式存储结构实现线性表"><a href="#链式存储结构实现线性表" class="headerlink" title="链式存储结构实现线性表"></a>链式存储结构实现线性表</h2><p>采用带表头结点的单链表作为线性表的物理结构，实现对多个单链表实现操作。</p>
<p>物理结构如下：</p>
<p><img src="/images/20150915/2.png" alt=""></p>
<p>可以借此设计个图书管理系统，数据对象为学校和书目。</p>
<p>学校即为上面线性表直接实现的，而书目即为链表实现。</p>
<p>修改下BElemType的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;BElemType;</span><br></pre></td></tr></table></figure>
<p>其中各学校功能函数定义与描述即为上述线性表的实现。</p>
<p>现在来实现某学校图书馆各书目索取函数定义与描述。</p>
<p>构造一个空的单链表：</p>
<p>主要思想是新建一链表头结点，开始时指针为空，名称为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BInitList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	*L = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>((*L)-&gt;elem.name, <span class="string">" "</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除单链表：</p>
<p>主要思想是依次遍历链表每个节点，释放存储空间，最后使头结点为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BDestroyList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	LinkList *q;</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">while</span> (*L) &#123;</span><br><span class="line">		q = *L;</span><br><span class="line">		*L = (*L)-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	*L = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空单链表：</p>
<p>主要思想即是与破坏链表不同在于还存在头结点，因此可结合新建链表与破坏链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BClearList</span><span class="params">(LinkList **L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	BDestroyList(L);</span><br><span class="line">	BInitList(L);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表是否空：</p>
<p>主要思想即判断头结点的next是否为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListEmpty</span><span class="params">(LinkList *L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表长度：</p>
<p>主要思想即添加计数变量i，依次循环遍历链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BListLength</span><span class="params">(LinkList *L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	LinkList *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i++, p = p-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下标找元素：</p>
<p>主要思想是通过输入的数，来确定遍历链表的次数，以此找到遍历的那个元素，来访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BGetElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, BElemType *e)</span> </span>&#123;</span><br><span class="line">	LinkList *p;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;BListLength(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++, p = p-&gt;next);</span><br><span class="line">	*e = p-&gt;elem;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过元素找下标：</p>
<p>主要思想是遍历链表的过程中通过比较函数比较链表数据和输入数据来确定位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int BLocateElem(LinkList *L, BElemType e, status (*compare)(BElemType e1, BElemType e2)) &#123;</span><br><span class="line">	if (L = NULL)</span><br><span class="line">		return ERROR;</span><br><span class="line">	LinkList *p = L-&gt;next;</span><br><span class="line">	int i = 1;</span><br><span class="line">	for (; p != NULL;p=p-&gt;next,i++)</span><br><span class="line">	&#123;</span><br><span class="line">	if(compare(e, p-&gt;elem))</span><br><span class="line">			return i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找前继：</p>
<p>主要思想是通过LocateElem得到输入元素的位置，再通过GetElem得到前一位置的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BPriorElem</span><span class="params">(LinkList *L, BElemType cur_e, BElemType *pre_e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> e_now;</span><br><span class="line">	e_now = BLocateElem(L, cur_e, Bequal);</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (e_now == ERROR) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BGetElem(L, e_now - <span class="number">1</span>, pre_e) == ERROR) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Bequal函数实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">Bequal</span><span class="params">(BElemType e1, BElemType e2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcpy</span>(e1.name, e2.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找后继：</p>
<p>思想同PriorElem。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BNextElem</span><span class="params">(LinkList *L, BElemType cur_e, BElemType *next_e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> e_now;</span><br><span class="line">	e_now = BLocateElem(L, cur_e, Bequal);</span><br><span class="line">	*next_e = L-&gt;elem;</span><br><span class="line">	<span class="keyword">if</span> (L = <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (e_now == ERROR)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BGetElem(L, e_now + <span class="number">1</span>, next_e) == ERROR)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<p>主要思想是将元素插入至新开辟的一个数据空间内，再改变链表指针指向即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListInsert</span><span class="params">(LinkList **L, <span class="keyword">int</span> i, BElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList *p, *pnow;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; BListLength(*L) + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	pnow = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">	pnow-&gt;elem = e;</span><br><span class="line">	<span class="keyword">if</span> (!pnow)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	p = *L;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; p != <span class="literal">NULL</span>; p = p-&gt;next, j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123;</span><br><span class="line">			pnow-&gt;next = p-&gt;next;</span><br><span class="line">			p-&gt;next = pnow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<p>主要思想是通过i遍历链表到该位置，通过e保存该数据，再free掉该指针所指向空间即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">BListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, BElemType *e)</span> </span>&#123;</span><br><span class="line">	LinkList *p,*q;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; BListLength(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	*e = p-&gt;next-&gt;elem;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="comment">//p = p-&gt;next;</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，基本的函数就完成了。</p>
<p>其中有一个易错点就是通过线性表来获取链表头结点，即通过学校进入图书馆。</p>
<p>先给出我的程序基本菜单：</p>
<p><img src="/images/20150915/3.png" alt=""></p>
<p>也即为六号功能。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	<span class="keyword">if</span> (Bflag) <span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n-----请输入学校号："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (GetElem(L, i) == OK)</span><br><span class="line">	&#123;</span><br><span class="line">		BB = &amp;(L.elem[i - <span class="number">1</span>].head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"查询成功，学校名为%s!\n"</span>, L.elem[i<span class="number">-1</span>].name);</span><br><span class="line">		Bflag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Wrong.Please input the i again."</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>线性表的操作便完全介绍完啦。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构概念总览]]></title>
      <url>//boyoung.me/2015/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%80%BB%E8%A7%88/</url>
      <content type="html"><![CDATA[<h1 id="计算机技术"><a href="#计算机技术" class="headerlink" title="计算机技术"></a>计算机技术</h1><p>计算机技术的两大支柱：1是数据结构，2是算法。</p>
<p>因此毫不夸张的在某种程度上讲，程序设计等同于设计数据结构+算法。 <a id="more"></a></p>
<h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p>线性结构的逻辑特征：有且仅有一个开始结点和终端结点，并且所有结点最多只有一个直接前驱和直接后继。如：线性表、栈、队列。</p>
<p>非线性结构的逻辑特征：一个结点可能有0、1、或多个直接前驱，直接后继。如：树、图、网、集合。</p>
<h2 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h2><p>顺序存储方法：把逻辑上相邻的结点存储在物理位置上相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。</p>
<p>链接存储方法：不要求逻辑上相邻的结点在物理位置上也相邻，结点间的逻辑关系由附加的指针字段表示。</p>
<p>索引存储方法：在存储结点信息的同时，还建立附加的索引表。</p>
<p>散列存储方法：根据结点的关键字直接计算出该结点的存储地址。</p>
<h2 id="简易分类"><a href="#简易分类" class="headerlink" title="简易分类"></a>简易分类</h2><p>线性表是一种逻辑结构，若采用顺序方法的存储表示，则为顺序表；若采用链接方法的存储表示，则为链表；若采用散列方法的存储表示，则为散列表；若对线性表上的插入、删除运算限制在表的一端进行，则为栈；若对插入限制在表的一端进行，而删除限制在表的另一端进行，则为队列。</p>
<p><img src="/images/20150910/1.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VS中scanf函数说明]]></title>
      <url>//boyoung.me/2015/08/02/VS%E4%B8%ADscanf%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>众所周知，由于安全原因，vs2012版本及其以上会出现scanf函数报错的情形，编译时便会提示如下错误<a id="more"></a>：</p>
<blockquote>
<p>error C4996: ‘scanf’: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
</blockquote>
<p>错误解释：</p>
<p>微软该种类型报错主要因为那些C库的函数，很多函数内部是不进行参数检测的（包括越界类的），微软担心使用这些会造成内存异常，所以就改写了同样功能的函数，改写了的函数进行了参数的检测，使用这些新的函数会更安全和便捷。关于这些改写的函数你不用专门去记忆，因为编译器对于每个函数在给出警告时，都会告诉你相应的安全函数，查看警告信息就可以获知，在使用时也再查看一下MSDN详细了解。</p>
<h3 id="一般来说，直接解决该问题方法有三种："><a href="#一般来说，直接解决该问题方法有三种：" class="headerlink" title="一般来说，直接解决该问题方法有三种："></a>一般来说，直接解决该问题方法有三种：</h3><p>方法一：将原来的旧函数替换成新的 Security CRT functions，即替换成为新的函数scanf_s，但是scanf_s函数比scanf函数多了一个参数，即读取个数参数。例如scanf从输入流中读取一个字符类型字节,scanf(“%c”,&amp;ch),则若使用scanf_s需改为scanf_s(“%c”,&amp;ch,1);</p>
<p>方法二：以下方法的原理为屏蔽这个错误：</p>
<ol>
<li>在预编译头文件stdafx.h里（注意：一定要在没有include任何头文件之前）定义下面的宏：</li>
</ol>
<blockquote>
<pre><code>#define _CRT_SECURE_NO_DEPRECATE
</code></pre></blockquote>
<ol>
<li><p>或声明 #param warning(disable:4996)</p>
</li>
<li><p>更改预处理定义：</p>
</li>
</ol>
<blockquote>
<p>项目-&gt;属性-&gt;配置属性-&gt;C/C++ -&gt; 预处理器 -&gt; 预处理器定义，增加：</p>
</blockquote>
<pre><code>_CRT_SECURE_NO_DEPRECATE
</code></pre><blockquote>
<p>第三种注意更改预处理定义时若在最后面加上该句话，需在这句话前面即未加之前最后面加上一个分号（在英文输入法模式下）。</p>
</blockquote>
<p>方法三：方法二没有使用更加安全的 CRT 函数，显然不是一个值得推荐的好方法，但我们又不想一个一个地改函数名，这里还有一个更简便的方法：</p>
<blockquote>
<p>在预编译头文件 stdafx.h 里（同样要在没有include任何头文件之前）定义下面的宏：</p>
</blockquote>
<pre><code>#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
</code></pre><blockquote>
<p>在链接的时候便会自动将旧函数替换成 Security CRT functions 。</p>
<p>注意：这个方法虽然使用了新的函数，但是不能消除警告，你还得同时使用方法二(-_-)。即实际应在预编译头文件 stdafx.h 里加入下面两句：</p>
</blockquote>
<pre><code>#define _CRT_SECURE_NO_DEPRECATE

#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
</code></pre><p>虽然解决了该报错问题，但是很多童鞋会发现运行时，scanf函数虽然并未报错，即该程序正确执行，但是在输入时，会发现scanf函数跳过输入字符的原因，即你没有办法输入的问题，这是为什么呢？</p>
<p>因为scanf只是读入一个字符,而你在输入时实际上输入的是:字符+回车(Enter),Enter产生的”\n”也在输入缓冲区中,下次调用 scanf时就会直接读到 它而不是等待你再次输入!所以我们不提倡使用 scanf(“%c”, …),特别是不提倡把它用在循环中。这也是微软改写该类函数的原因，那么如何解决呢？</p>
<h3 id="一把来说，主要方法有四种："><a href="#一把来说，主要方法有四种：" class="headerlink" title="一把来说，主要方法有四种："></a>一把来说，主要方法有四种：</h3><p>方法一：只要再加一句scanf就行了。</p>
<p>方法二：使用函数fflush，清除流，就是在每个接收字符的scanf语句前面,加上fflush(stdin);</p>
<p>方法三：将 scanf(“%c”, &amp;ch); 修改为:     scanf(“ %c”, &amp;ch);    /<em>在%前加上一个空格</em>/</p>
<p>方法四：将 scanf(“%c”, &amp;ch); 修改为:     scanf(“%c%<em>c”, &amp;ch);   %</em>c是跳过一个输入字符的意思.这个是scanf的一个语法.就是在%和格式字符之间加一个<em>号就可以跳过这个输入数字.比如当执行语句:scanf(“%c,%</em>c,%c”,&amp;a,&amp;b);时,我输入m,n,p三个字母后,a的值为m,b值为p,n被跳过了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客]]></title>
      <url>//boyoung.me/2015/07/11/Hexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="Hexo博客初建"><a href="#Hexo博客初建" class="headerlink" title="Hexo博客初建"></a>Hexo博客初建</h2><p>闲来无事，便打算给自己做一个个人网站，用于分享知识、记录心情的个人小站，最后喜欢上了hexo，这是初衷。<a id="more"></a></p>
<p>具体的搭建方法也是参考的别人，具体详见<a href="http://qrframe.com/2016/07/13/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/" target="_blank" rel="external">使用hexo搭建个人网站</a>。</p>
<p>我使用的主题为yelee，简洁、美观而又大方。具体的可以详细搜索做这个主题前端的大佬，可以详细参考下。</p>
<p>博客搭建好后，还可以绑定自己的域名，我使用的域名boyoung.me便是从阿里云购买的，详细绑定方法见<a href="http://quantumman.me/blog/setting-up-a-domain-with-gitHub-pages.html" target="_blank" rel="external">GitHub Pages 绑定来自阿里云的域名</a>。</p>
<h2 id="Hexo简单使用"><a href="#Hexo简单使用" class="headerlink" title="Hexo简单使用"></a>Hexo简单使用</h2><h3 id="1、new"><a href="#1、new" class="headerlink" title="1、new"></a>1、new</h3><blockquote>
<p>hexo new [layout] <title></title></p>
</blockquote>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="2、generate"><a href="#2、generate" class="headerlink" title="2、generate"></a>2、generate</h3><blockquote>
<p>hexo g</p>
</blockquote>
<p>生成静态文件。</p>
<h3 id="3、server"><a href="#3、server" class="headerlink" title="3、server"></a>3、server</h3><blockquote>
<p>hexo s</p>
</blockquote>
<p>启动服务器。</p>
<h3 id="4、deploy"><a href="#4、deploy" class="headerlink" title="4、deploy"></a>4、deploy</h3><blockquote>
<p>hexo g</p>
</blockquote>
<p>部署网站。</p>
<h3 id="5、clean"><a href="#5、clean" class="headerlink" title="5、clean"></a>5、clean</h3><blockquote>
<p>hexo clean</p>
</blockquote>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Future]]></title>
      <url>//boyoung.me/2015/07/10/Hello-Future/</url>
      <content type="html"><![CDATA[<p>撒花撒花，博客搭好，当然要立一些flags啦！希望这个hexo博客能让我更加进步！<a id="more"></a></p>
<h2 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h2><h3 id="College"><a href="#College" class="headerlink" title="College"></a>College</h3><blockquote>
<p>Huazhong University of Science and Technology.</p>
</blockquote>
<h3 id="Hobby"><a href="#Hobby" class="headerlink" title="Hobby"></a>Hobby</h3><blockquote>
<p>Tennis, Music, Reading.</p>
</blockquote>
<h3 id="Dream-Flags"><a href="#Dream-Flags" class="headerlink" title="Dream? Flags!"></a>Dream? Flags!</h3><blockquote>
<p>Le vent se lève, il faut tenter de vivre.</p>
</blockquote>
<h3 id="Maxim"><a href="#Maxim" class="headerlink" title="Maxim"></a>Maxim</h3><blockquote>
<p>以最小的代价完成生命各个维度的尝试。</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
